<html>	<head>
	<title>
Standard and unstandard control-flow words
	</title>
	</head>
	<body>
	<h1>
Стандартные и нестандартные структуры управления в Форт-системе T32
	</h1>
	<i>
(c) ООО ИТФ "Технофорт, 2000
	<br>
(c) М.Л.Гасаненко, 2000
	<br>
Данная статья является частью документации к Форт-системе T32 фирмы
<a href="../../~TechnoForth/index.html">ООО ИТФ "Технофорт"</a>
(см. также <a href="http://www.forth.org.ru/~TechnoForth/news.htm">страницу новостей</a>).
Данная статья может свободно (т.е. бесплатно) распространяться в электронном
виде по сетям Internet и Fido при условии неизвлечения прибыли (оплата траффика
не в счет),
при этом данная статья не должна быть изменена.
Запрещается публикация и распространение данной статьи любыми другими
методами и средствами (включая поставку вместе с программным обеспечением)
без письменного согласия владельцев авторских прав.
	<p>
Изменения:
<br>
09.10.2001
Добавлен раздел <a href="ctlflow.htm#dowhile">"Конструкция <code>DO ... WHILE ... LOOP ... ELSE ... UNLOOP THEN</code>"</a>.
	<br>
15.10.2000 для Т32-Форта версии 1.02

	</i>
	<h2>
Содержание
	</h2>
<a href="ctlflow.htm#intro">
Введение
	<br>
<a href="ctlflow.htm#std">
Стандартные структуры управления</a>
	<br>
&nbsp;&nbsp;
<a href="ctlflow.htm#class">
Классические структуры управления</a>
	<br>
&nbsp;&nbsp;
<a href="ctlflow.htm#principles">
Принципы реализации структур управления</a>
	<br>
&nbsp;&nbsp;
<a href="ctlflow.htm#principlesresume">
Принципы реализации структур управления - резюме</a>
	<br>
&nbsp;&nbsp;
<a href="ctlflow.htm#words">
Слова, реализующие структуры управления</a>
	<br>
&nbsp;&nbsp;
<a href="ctlflow.htm#wordsexamples">
Слова, реализующие структуры управления - примеры использования</a>
	<br>
&nbsp;&nbsp;
<a href="ctlflow.htm#wordsspecs">
Стековые эффекты и описания наиболее важных стандартных компилирующих слов</a>
	<br>
&nbsp;&nbsp;
<a href="ctlflow.htm#nonclass">
Стандартные неклассические структуры управления</a>
	<br>
<a href="ctlflow.htm#unstd">
Нестандартные структуры управления</a>
	<br>
&nbsp;&nbsp;<a href="ctlflow.htm#dowhile">
Конструкция <code>DO ... WHILE ... LOOP ... ELSE ... UNLOOP THEN</code></a>
	<br>
&nbsp;&nbsp;<a href="ctlflow.htm#caseesac">
Конструкция <code>CASE ... ESAC</code></a>
	<br>
&nbsp;&nbsp;&nbsp;&nbsp;
<a href="ctlflow.htm#caseimplem">
Реализация</a>
	<br>
&nbsp;&nbsp;&nbsp;&nbsp;
<a href="ctlflow.htm#caseofif">
Использование <nobr><code>CASE ... ESAC</code></nobr> в операторе множественного ветвления</a>
	<br>
&nbsp;&nbsp;&nbsp;&nbsp;
<a href="ctlflow.htm#casecandcor">
Использование <nobr><code>CASE ... ESAC</code></nobr> для сокращенного вычисления булевских выражений</a>
	<br>
&nbsp;&nbsp;&nbsp;&nbsp;
<a href="ctlflow.htm#casewhile">
Использование <nobr><code>CASE ... ESAC</code></nobr> для разрешения нескольких <code>WHILE</code></a>
	<br>
&nbsp;&nbsp;&nbsp;&nbsp;
<a href="ctlflow.htm#caseifif">
Использование <nobr><code>CASE ... ESAC</code></nobr> для проверки нескольких условий в условном операторе без части "иначе"</a>
	<br>
&nbsp;&nbsp;&nbsp;&nbsp;
<a href="ctlflow.htm#caseelesac">
Использование <nobr><code>CASE ... ESAC</code></nobr> для проверки нескольких условий в условном операторе с частью "иначе"</a>
	<br>
&nbsp;&nbsp;
<a href="ctlflow.htm#jbrien">
Временное снятие значений <i>orig</i> и <i>dest</i> со стека</a>
	<br>
&nbsp;&nbsp;
<a href="ctlflow.htm#nodepth">
Почему не стоит запоминать глубину стека компилятора</a>
	<br>
&nbsp;&nbsp;
<a href="ctlflow.htm#done">
<code>DONE</code>: еще один способ организации цикла с несколькими выходами</a>
	<br>
&nbsp;&nbsp;
<a href="ctlflow.htm#startemerge">
Рекурсивный блок <nobr><code>START ... EMERGE</code></nobr></a>
	<br>
&nbsp;&nbsp;&nbsp;&nbsp;
<a href="ctlflow.htm#startimpl">
Реализация</a>
	<br>
&nbsp;&nbsp;&nbsp;&nbsp;
<a href="ctlflow.htm#startrec">
Пример 1 - рекурсия</a>
	<br>
&nbsp;&nbsp;&nbsp;&nbsp;
<a href="ctlflow.htm#startaux">
Пример 2 - замена вспомогательного определения</a>
	<br>
&nbsp;&nbsp;
<a href="ctlflow.htm#btrk">
Упоминание о бэктрекинге (backtracking)</a>
	<p>
<!--=====================================================-->
<a name="intro"></a>
	<h2>
Введение
	</h2>
Целью введения какой-либо структуры управления в язык программирования
должно быть создание такой формы организации кода, с которой удобно
работать человеку.
<strong>Конечной целью является удобство работы с кодом.</strong>
	<p>
При этом даже если какая-то структура управления требует приобретения человеком
специфических знаний или навыков, это может (при определенных условиях)
считаться приемлемым.
Однако обязательным условием применения структуры управления в приложении
является выигрыш в затрачиваемых на работу с кодом усилиях.
	<p>
Кроме этого, выбор тех или иных структур управленния — дело вкуса.
(Когда мы чувствуем, что что-то должно быть так, а не иначе, и не можем
объяснить почему, мы объясняем это вкусом.
Возможно, что психолог тут смог бы говорить об объективных закономерностях
человеческого мышления.
<!-- 
Возможно, что ответ на вопрос
"почему" находится в сфере психологии. Например, система
<nobr><i><tt>GOTO</tt> метка<tt> </tt>...<tt> </tt>метка: ...</i><tt> </tt></nobr>
воспринимается человеком не как один, а как два объекта, в отличие от
структуры <nobr><code>IF ... THEN</code></nobr>.
Учитывая, что количество объектов, которые человек способен одновременно 
держать в сознании, ограниченно (обычно <nobr>7 плюс-минус 2),</nobr> метки просто
неудобны из-за того, что требуют больших затрат человеческой памяти.
Однако не всякий программист способен выдать соответствующую тираду.
Иногда люди не принимают какие-то вещи из-за того, что не хотят или не могут
больше учиться, при этом причина может или высказываться или не высказываться
вслух. Так что выразительные средства языка программирования — дело тонкое.
-->)
	<p>
<a name="std"></a>
	<h2>
Стандартные структуры управления
	</h2>
<a name="class"></a>
	<h3>
Классические структуры управления
	</h3>
Стандартными структурами управления являются:
<p>
<code>
IF ... THEN<br>
IF ... ELSE ... THEN<br>
BEGIN ... WHILE ... REPEAT<br>
BEGIN ... UNTIL<br>
BEGIN ... AGAIN<br>
DO ... LOOP<br>
?DO ... LOOP<br>
DO ... +LOOP<br>
?DO ... +LOOP<br>
CASE </code><i>{</i><code> ... OF ... ENDOF </code><i>}</i><code> ... ENDCASE<br>
</code>
<p>
(Фигурными скобками '<i>{</i>' и '<i>}</i>' выделена часть, которая может
повторяться 0 или более раз.)
Эти структуры управления описаны в учебниках и здесь не рассматриваются.
	<p>
	<a name="principles"></a>
	<h3>
Принципы реализации структур управления
	</h3>
<strong>Переходы вперед</strong> порождаются в два приема:
	<ol>
	<li>
сначала порождается команда перехода по неуказанному адресу назначения,
при этом вырабатывается значение <i>orig</i> (origin — исходная точка),
содержащее информацию о недостроенном переходе вперед, в том числе адрес
команды перехода;
	<li>
когда адрес назначения становится известен, значение <i>orig</i> используется
для записи адреса назначения в команду перехода.
	</ol>
В стандарте ANS Forth говорится, что значения <i>orig</i> и <i>dest</i>
(см. далее) помещаются на <em>стек компилятора</em> (там он называется 
control-flow stack, стек потока управления). В том же стандарте
говорится, что в качестве стека компилятора может использоваться стек данных.
(Использование стека данных компилятором во время компиляции
не мешает использовать стек данных для передачи параметров во время исполнения.)
Чтобы не путать стековые комментарии времени компиляции и времени исполнения,
стековые комментарии времени компиляции принято выделять меточкой "C:".
	<p>
Например,
<pre>
\ IF   ( C: -- orig )
\ THEN ( C: orig -- )
: 0MAX
	DUP 0<			( C:  )
	IF			( C: orig )
		DROP 0		( C: orig )
	THEN			( C:  )
;
</pre>
Слово <code>IF</code> порождает команду перехода неизвестно куда,
а слово <code>THEN</code> указывает, куда именно нужно осуществлять переход.
Значение <i>orig</i> нужно для того, чтобы слово <code>THEN</code> знало,
какую команду нужно поправить.
	<p>
<strong>Переходы назад</strong> порождаются также в два приема:
	<ol>
	<li>
сначала выясняется, куда нужен переход,
и вырабатывается значение <i>dest</i> (destination - место назначения),
содержащее информацию об адресе назначения еще не построенного
перехода;
	<li>
затем значение <i>dest</i> используется для построения команды перехода
по этому адресу.
	</ol>
Например,
<pre>
\ BEGIN ( C: -- dest )
\ UNTIL ( C: dest -- )
\ convert digits until the quotient is zero
: #S ( ud1 -- ud2 )
				( C:  )
	BEGIN			( C: dest )
		#		( C: dest )
		2DUP D0=	( C: dest )
	UNTIL			( C:  )
;
</pre>
Слово <code>BEGIN</code> вырабатывает значение <i>dest</i> с информацией,
по какому адресу нужно вернуться, а слово <code>UNTIL</code> порождает
условный переход на этот адрес.
	<p>
	<a name="principlesresume"></a>
	<h3>
Принципы реализации структур управления — резюме
	</h3>
Итак,
	<strong>
<i>orig</i> является описателем недостроенного перехода вперед,
а <i>dest</i> является описателем недостроенного перехода назад.
Построение команды перехода осуществляется в два приема, при этом
слово, начинающее построение перехода, возвращает описатель, который
надо передать слову, завершающему построение перехода.
Описатели недостроенных переходов передаются через стек.
	</strong>
	<p>
	<a name="words"></a>
	<h3>
Слова, реализующие структуры управления
	</h3>

<code>AHEAD </code><i>( C: -- orig )</i> порождает безусловный переход вперед.
Адрес назначения указывается словом <code>THEN</code>, так что можно считать,
что вся конструкция имеет вид
	<p>
<code>AHEAD ... THEN</code>
	<p>
Такое использование слова <code>AHEAD</code> на практике встречается
крайне редко, хотя и является допустимым.
Слово <code>AHEAD</code> предназначено для использования <em>внутри других
компилирующих слов</em>, в том числе компилирующих слов, определяемых пользователем.
	<p>
Слова <code>CS-PICK</code>, <code>CS-ROLL</code>, <code>CS-DROP</code> и
<code>CS-SWAP</code> предназначены для манипулирования со значениями
<i>orig</i> и <i>dest</i>. В отличие от слов, реализующих структуры управления
(например, <code>IF</code>), эти слова <em>не имеют признака IMMEDIATE</em>.
	<p>
На приведенных ниже стековых диаграммах символ <i>od</i> обозначает значение
<i>orig</i> или <i>dest</i>.
	<p>
<code>CS-PICK </code><i>
( C: od[u] ... od[0] u -- od[u] ... od[0] od[u] )</i>
Скопировать <i>u</i>-ое значение <i>orig</i> или <i>dest</i>
(нумерация начинается от вершины стека с нуля).
	<br>
<code>CS-ROLL </code><i>
( C: od[u] od[u-1] ... od[0] u -- od[u-1] ... od[0] od[u] )</i>
Переместить <i>u</i>-ое значение <i>orig</i> или <i>dest</i> из глубины стека на вершину
(нумерация начинается от вершины стека с нуля).
	<br>
<code>CS-DROP </code><i>( C: od -- )</i> Убрать со стека значение
<i>orig</i> или <i>dest</i>.
	<br>
<code>CS-SWAP </code><i>( C: od[1] od[2] -- od[2] od[1] )</i>
Поменять местами на стеке два значения <i>orig</i> или <i>dest</i>.
	<p>
Из этих слов <code>CS-PICK</code> и <code>CS-ROLL</code> являются стандартными,
а <code>CS-DROP </code> предложено для включения в стандарт 2001(?) года.
Слово же <code>CS-SWAP</code> можно определить через <code>CS-ROLL</code> как:
<pre>
: CS-SWAP 1 CS-ROLL ;
</pre>
	<p>
	<a name="wordsexamples"></a>
	<h3>
Слова, реализующие структуры управления — примеры использования
	</h3>
Пример использования слова <code>CS-SWAP</code>:
<pre>
: ELSE ( orig1 -- orig2 ) [COMPILE] AHEAD CS-SWAP [COMPILE] THEN ; IMMEDIATE
</pre>
(Слова <code>[COMPILE]</code> будут объяснены позднее).
	<p>
В конструкции <code>IF ... ELSE ... THEN</code>
слово <code>IF</code> порождает команду условного перехода вперед (не указывая
адреса назначения) и оставляет на стеке значение <i>orig1</i>.
Слово <code>ELSE</code> порождает команду безусловного перехода вперед
(на стеке остается <i>orig2</i>), меняет местами этот <i>orig2</i> с
оставленным словом <code>IF</code> значением <i>orig1</i>,
и вызывает слово <code>THEN</code>, завершая начатое словом <code>IF</code>
построение команды условного перехода.
На стеке остается <i>orig2</i>, дожидающийся своего слова <code>THEN</code>.
Еще раз:
<pre>
			( C:   )
	IF		( C: orig1 )
		...	( C: orig1 )
	ELSE		( C: orig2 )
		...	( C: orig2 )
	THEN		( C:   )
</pre>
или, с учетом определения слова <code>ELSE</code>,
<pre>
			( C:   )
	IF		( C: orig1 )
		...	( C: orig1 )
	AHEAD		( C: orig1 orig2 )
	[ CS-SWAP ]	( C: orig2 orig1 )
	THEN		( C: orig2 )
		...	( C: orig2 )
	THEN		( C:   )
</pre>
Теперь о словах <code>[COMPILE]</code>.
Если мы напишем
<pre>
: foo  AHEAD CS-SWAP THEN ; IMMEDIATE
</pre>
то слова <code>AHEAD</code> и <code>THEN</code> выполнятся во время компиляции,
и получится слово, которое ничего не делает. При обращении к этому слову
выполнится перожденный словом <code>AHEAD</code> переход на <code>THEN</code>,
после чего будет выполнен выход из процедуры. Чтобы слова
<code>AHEAD</code> и <code>THEN</code> скомпилировались, перед ними
пишется <code>[COMPILE]</code>.
	<p>
Еще один пример.
<pre>
: WHILE     [COMPILE] IF CS-SWAP ; IMMEDIATE
: REPEAT    [COMPILE] AGAIN [COMPILE] THEN ; IMMEDIATE
</pre>
Вот как это работает:
<pre>
	BEGIN		( C: dest )
		...	( C: dest )
	WHILE		( C: orig dest )
		...	( C: orig dest )
	REPEAT		( C:  )
</pre>
или, более подробно,
<pre>
	BEGIN		( C: dest )
		...	( C: dest )
	IF		( C: dest orig )
	[ CS-SWAP ]	( C: orig dest )
		...	( C: orig dest )
	AGAIN		( C: orig )
	THEN		( C:  )
</pre>
Нетрудно видеть, что <code>WHILE</code> (вызывая слово <code>IF</code>)
начинает построение условного перехода вперед, а <code>REPEAT</code>
(вызывая слово <code>THEN</code>) завершает построение команды перехода.

	<p>
	<a name="wordsspecs"></a>
	<h3>
Стековые эффекты и описания наиболее важных стандартных компилирующих слов
	</h3>
<code>IF </code><i>( C: -- orig )</i> Начать построение условного перехода вперед<br>
<code>AHEAD </code><i>( C: -- orig )</i> Начать построение безусловного перехода вперед<br>
<code>THEN </code><i>( C: orig -- )</i> Закончить построение перехода вперед<br>
<code>ELSE </code><i>( C: orig1 -- orig2 )</i> Выполняет слова <code>AHEAD CS-SWAP THEN</code><br>
<code>BEGIN </code><i>( C: -- dest )</i> Начать построение перехода назад<br>
<code>UNTIL </code><i>( C: dest -- )</i> Закончить построение условного перехода назад<br>
<code>AGAIN </code><i>( C: dest -- )</i> Закончить построение безусловного перехода назад<br>
<code>WHILE </code><i>( C: od -- orig od )</i> Выполняет слова <code>IF CS-SWAP</code><br>
<code>REPEAT </code><i>( C: dest orig -- )</i> Выполняет слова <code>AGAIN THEN</code><br>
<p>
Замечание. Фраза "выполняет слова" не означает, что приведенный далее текст
можно помещать в фортовское определение. Если Вы хотите скомпилировать
вызовы этих слов в текущее определение, то перед словами с признаком IMMEDIATE
надо ставить <code>[COMPILE]</code>, например, <nobr><code>[COMPILE] IF</code></nobr>.
А если Вы хотите выполнить эти слова при компиляции текущего определения, то
слова без признака IMMEDIATE надо заключить в квадратные скобки, например
<nobr><code>[ CS-SWAP ]</code></nobr>.
	<p>
	<a name="nonclass"></a>
	<h3>
Стандартные неклассические структуры управления
	</h3>
Раз уж <code>REPEAT</code> является сокращением для
<nobr><code>AGAIN THEN</code></nobr>,
почему бы нам не завести цикл с двумя <code>WHILE</code>,
завершающийся фразой <nobr><code>AGAIN THEN THEN</code></nobr>?
Или с тремя <code>WHILE</code>, завершающийся фразой
<nobr><code>AGAIN THEN THEN THEN</code></nobr>?
	<p>
Ответ: стандарт языка Форт позволяет это. Приведем несколько примеров.
	<p>
Пример 1.
<pre>
	BEGIN		( C: dest )
		...	( C: dest )
	WHILE		( C: orig1 dest )
		...	( C: orig1 dest )
	WHILE		( C: orig1 orig2 dest )
		...	( C: orig1 orig2 dest )
	AGAIN		( C: orig1 orig2 )
	THEN		( C: orig1 )
	THEN		( C:  )
</pre>
Пример 2. То же самое, но с использованием <code>REPEAT</code>.
<pre>
	BEGIN		( C: dest )
		...	( C: dest )
	WHILE		( C: orig1 dest )
		...	( C: orig1 dest )
	WHILE		( C: orig1 orig2 dest )
		...	( C: orig1 orig2 dest )
	REPEAT		( C: orig1 )
	THEN		( C:  )
</pre>
Пример 3. Выход из цикла возможен как через <code>WHILE</code>,
так и через <code>UNTIL</code>.
<pre>
	BEGIN		( C: dest )
		...	( C: dest )
	WHILE		( C: orig dest )
		...	( C: orig dest )
	UNTIL		( C: orig )
	THEN		( C:  )
</pre>
Пример 4. В зависимости от того, невыполнение какого условия привело
к прекращению цикла, нужно выполнить те или иные действия.
<pre>
	BEGIN		( C: dest )
		...	( C: dest )
	WHILE		( C: orig1 dest )
		...	( C: orig1 dest )
	UNTIL		( C: orig1 )
	\ если вышли через until
		...	( C: orig1 )
	ELSE		( C: orig2 )
	\ если вышли через while
		...	( C: orig2 )
	THEN		( C:  )
	...	    \ общая часть
</pre>
Пример 5. В зависимости от того, невыполнение какого условия привело
к прекращению цикла, нужно выполнить те или иные действия.
<pre>
	BEGIN		( C: dest )
		...	( C: dest )
	WHILE		( C: orig1 dest )
		...	( C: orig1 dest )
	WHILE		( C: orig1 orig2 dest )
		...	( C: orig1 orig2 dest )
	AGAIN		( C: orig1 orig2 )
	THEN		( C: orig1 )
	\ если вышли через второй while
		...	( C: orig1 )
	ELSE		( C: orig3 )
	\ если вышли через первый while
		...	( C: orig3 )
	THEN		( C:  )
	...	    \ общая часть
</pre>
Разумеется, <code>AGAIN THEN</code> можно заменить на <code>REPEAT</code>.
	<p>
Вот что говорится в стандарте ANS Forth (American National Standard for
Information Systams — Programming Languages — Forth, American National
Standards Institute, 1994):
	<p>
"[Известные читателю] основные структуры управления могут быть дополнены,
как показано на примерах ... (см. выше — <i>М.Г.</i>), конструкциями
<nobr><code>BEGIN ... UNTIL</code></nobr>
и <nobr><code>BEGIN ... WHILE ... REPEAT</code></nobr>
с добавочными <code>WHILE</code>.
Однако, для каждого добавочного <code>WHILE</code> в конце структуры
необходим <code>THEN</code>.
<code>THEN</code> и <code>WHILE</code> образуют единую систему,
<code>THEN</code> показывает, с какого места следует продолжать
исполнение когда <code>WHILE</code> передает управление.
Использование более чем одного добавочного <code>WHILE</code>
возможно, но случается редко.
Обратите внимание, что если пользователь находит такое использование
<code>THEN</code> нежелательным, можно определить слово-синоним
с более привлекательным именем."
	<p>
"Дополнительные действия могут быть выполнены между словом,
завершающим цикл (<code>REPEAT</code> или <code>UNTIL</code>)
и словом <code>THEN</code>, соответствующим
добавочному <code>WHILE</code>. Более того, если для случаев
раннего завершения и нормального завершения требуются дополнительные,
взаимоисключающие действия, эти действия могут быть отделены
друг от друга обычным фортовским <code>ELSE</code>.
Все действия при завершении цикла указываются после конца цикла."
	<p>
Обратите внимание, что когда <code>WHILE</code> ставится в соответствие 
<code>ELSE</code> или <code>THEN</code>, <code>REPEAT</code> создает 
некоторую неправильность, больше всего заметную при сравнении со случаем
<nobr><code>BEGIN ... UNTIL</code></nobr>. Дело в том, что число
<code>ELSE</code> или <code>THEN</code> будет на единицу меньше числа
слов <code>WHILE</code> из-за того, что <code>REPEAT</code>
[один раз выполняет <code>THEN</code>, разрешая одно 
<code>WHILE</code> (<i>здесь в стандарте небольшая путаница — М.Г.</i>)].
Как и в вышеупомянутом случае, если
пользователь находит такое несоответствие в подсчете
нежелательным, <code>REPEAT</code> можно заменить в исходном тексте на
его собственное определение (то есть, на <nobr><code>AGAIN THEN</code></nobr>
— <i>М.Г.</i>)."
	<p>
	<a name="unstd"></a>
	<h2>
Нестандартные структуры управления
	</h2>
	<p>
	<a name="dowhile"></a>
	<h3>
Конструкция <code>DO ... WHILE ... LOOP ... ELSE ... UNLOOP THEN</code>
	</h3>
Строго говоря, стандарт не позволяет использовать <code>WHILE</code> внутри
цикла <code>DO ... LOOP</code>, т.к. размер значения <i>do-sys</i> может 
отличаться от размера <i>orig</i> и <i>dest</i>. В Форте T32, однако,
размеры <i>do-sys</i>, <i>orig</i> и <i>dest</i> совпадают.
<p>
Marcel Hendrix в сообщении &lt;9pq1s2$46g$1@news.IAEhv.nl&gt; привел
следующий пример:
<pre><code>
CREATE tbl  1 , 2 , 4 , 33 , 77 , 7 , 0 , 457 , 99 , 100 ,
 
: .OK? ( -- )
       10 0 DO      I CELLS tbl + @ 456 < 
             WHILE  I .
            LOOP    CR ." All values OK"
             ELSE   CR ." Bad value in tbl: " I . UNLOOP
             THEN
         CR ." Finished checking the table" ;

.OK?
0 1 2 3 4 5 6
Bad value in tbl: 7
Finished checking the table ok[Dec]
</code></pre>
Обратите внимание на то, что если в массиве оказывается "плохой" элемент
(больший 456), <code>WHILE</code> передает управление на код за
<code>ELSE</code>, т.е. за пределы цикла, однако параметры цикла со стека
возвратов еще не убраны. Мы можем получить значение счетчика цикла с помощью
слова <code>I</code>, однако убирать параметры цикла нам приходится самим —
мы применяем слово <code>UNLOOP</code>. Если бы мы забыли слово <code>UNLOOP</code>,
это скорее всего закончилось бы ошибкой "access violation".
	<p>
Разумеется, ничто не препятствует использовать <a href="ctlflow.htm#done">слово <code>DONE</code></a>
или <a href="ctlflow.htm#nonclass">несколько частей <code>WHILE</code></a> (включая
<a href="ctlflow.htm#casewhile">использование <code>CASE ... ESAC</code> для разрешения 
нескольких <code>WHILE</code></a> или даже применение для этого
<a href="ctlflow.htm#caseelesac"><code>CASE ... ELESAC ... THEN</code></a>).
Не увлекайтесь, однако наворотами. Подобные структуры управления нужны <em>очень</em> редко.

	<p>
	<a name="caseesac"></a>
	<h3>
Конструкция <code>CASE ... ESAC</code>
	</h3>
Эту конструкцию предложил Wil Baden.
<!-- (человек, который по некоторым сведениям
и разработал для стандарта ANS Forth спецификацию компилирующих слов,
допускающую балансировку слова <code>WHILE</code> словом <code>THEN</code>).
-->
Точнее, у него в разное время
<code>ESAC</code> работал по-разному, а то, что описано здесь,
является некоторой переработкой. По крайней мере, идеи использования
слова <b>esac</b> в качестве имени фортовского слова, а также
применения <code>ESAC</code> для сокращенного вычисления булевских выражений
и для разрешения нескольких <code>WHILE</code> я узнал от него
через телеконференцию comp.lang.forth.
(По некоторым сведениям, это Wil Baden разработал для ANSI-стандарта
спецификацию <a href="ctlflow.htm#nonclass">взаимодействия</a> компилирующих слов,
таких как <code>WHILE</code> и <code>THEN</code>). 
	<p>
Слово <code>CASE</code> оставляет на стеке компилятора пометку.
После слова <code>CASE</code> на стеке компилятора может остаться
любое количество значений <i>orig</i> (описателей перехода вперед).
Слово <code>ESAC</code> завершит построение всех переходов, описатели
которых лежат выше отметки, выполнив для каждого из этих значений слово
<code>THEN</code>.
	<p>
В конструкции
	<br>
	<tt>
CASE </tt><i>{</i><tt> ... OF ... ENDOF </tt><i>}</i><tt> ... ESAC
	</tt>
	<br>
<code>ESAC</code> отличается от <code>ENDCASE</code> только тем, что
<code>ENDCASE</code> компилирует <code>DROP</code>:
	<br>
	<tt>
CASE </tt><i>{</i><tt> ... OF ... ENDOF </tt><i>}</i><tt> ... ENDCASE
	</tt>
	<br>
эквивалентно
	<br>
	<tt>
CASE </tt><i>{</i><tt> ... OF ... ENDOF </tt><i>}</i><tt> ... DROP ESAC
	</tt>
	<p>
Если использование конструкции <nobr><code>CASE ... ESAC</code></nobr>
ограничено только что упомянутым случаем, то <code>ESAC</code> можно
определить как эквивалент <nobr><code>0 ENDCASE</code></nobr>.
Однако, неверно было бы считать, что <code>ESAC</code> эквивалентно
<nobr><code>0 ENDCASE</code></nobr> в общем случае: внутри стандартной
конструкции <nobr><code>CASE ... ENDCASE</code></nobr> можно использовать
только <nobr><code>OF ... ENDOF</code></nobr>.
	<p>
Слово <b>esac</b> (по-русски читается "езак") является словом
<b>case</b>, написанным наоборот. Впервые этот словесный урод появился
в Пересмотренном сообщении об алгоритмическом языке Алгол-68
(Ван-Вийнгаарден и др.).


	<p>
	<a name="caseimplem"></a>
	<h4>
Реализация
	</h4>
<pre>
: CASE      ?COMP   $CA5E 0 ; IMMEDIATE
: OF        ?COMP   COMPILE (OF)  >MARK ; IMMEDIATE
: ENDOF     ?COMP   [COMPILE] ELSE ; IMMEDIATE
: ESAC      ?COMP
            BEGIN   ?DUP WHILE  [COMPILE] THEN     REPEAT
            $CA5E ?PAIRS
; IMMEDIATE
: ENDCASE   ?COMP   COMPILE DROP [COMPILE] ESAC
; IMMEDIATE
: ELESAC    [COMPILE] AHEAD  2>R   [COMPILE] ESAC   2R>
; IMMEDIATE
</pre>
Слово <code>ELESAC</code> описано ниже.
	<p>
О подходах к реализации см. также в разделе
"<a href="ctlflow.htm#nodepth">Почему не стоит запоминать глубину стека компилятора</a>".



	<p>
	<a name="caseofif"></a>
	<h4>
Использование <nobr><code>CASE ... ESAC</code></nobr> в операторе множественного ветвления
	</h4>
Конструкция выглядит так:
	<p>
<tt>
CASE ( n ) <br>
&nbsp; </tt><i>значение1</i><tt> ( n n1 ) OF ( &nbsp;&nbsp;) </tt><i>действия-A1</i><tt> ENDOF<br>
&nbsp; </tt><i>условие1</i><tt> &nbsp;( n f1 ) IF ( n ) </tt><i>действия-B1</i><tt> ENDOF<br>
&nbsp; ...<br>
&nbsp; </tt><i>значениеN</i><tt> ( n nN ) OF ( &nbsp;&nbsp;) </tt><i>действия-AN</i><tt> ENDOF<br>
&nbsp; </tt><i>условиеM</i><tt> &nbsp;( n fM ) IF ( n ) </tt><i>действия-BM</i><tt> ENDOF<br>
&nbsp; ( n ) </tt><i>действия-в-противном-случае</i><tt><br>
ESAC<br>
</tt>
<p>
в конструкции можно использовать <code>IF</code> и <code>OF</code> вперемешку,
	<br>
слово <code>OF</code> эквивалентно фразе <code>OVER = IF DROP</code>,
	<br>
слова <code>ENDOF</code> и <code>ELSE</code> являются синонимами,
	<br>
<i>значени</i>я должны иметь стековый эффект <i>( -- n )</i> или <i>( n1 -- n1 n2 )</i>,
	<br>
<i>услови</i>я должны иметь стековый эффект <i>( n -- n flag )</i>,
	<br>
<i>действия-в-противном-случае</i> должны снять со стека значение <i>n</i>.

	<p>
	<a name="casecandcor"></a>
	<h4>
Использование <nobr><code>CASE ... ESAC</code></nobr> для сокращенного вычисления булевских выражений
	</h4>
<pre>
: CAND POSTPONE DUP POSTPONE IF POSTPONE DROP ; IMMEDIATE
: COR  POSTPONE DUP POSTPONE IFNOT POSTPONE DROP ; IMMEDIATE
</pre>
Слово <b>cand</b> ("канд") означает <b>c</b>onditional <b>and</b>,
а <b>cor</b> ("кор") — <b>c</b>onditional <b>or</b>.
Или, если угодно, <b>с</b>окращенные <b>and</b> и <b>or</b>.
Или <b>and</b> и <b>or</b> для использования внутри <b>c</b>ase.
Конструкция выглядит так:
	<p>
<tt>
CASE
 </tt><i>условие1</i><tt> CAND
 </tt><i>условие2</i><tt> CAND
...
 </tt><i>условиеN</i><tt> ESAC
</tt>
	<p>
или
	<p>
<tt>
CASE
 &nbsp;</tt><i>условие1</i><tt> COR
 &nbsp;</tt><i>условие2</i><tt> COR
...
 </tt><i>условиеN</i><tt> ESAC
</tt>
	<p>
Каждое <i>условие</i> и вся конструкция в целом имеют стековый эффект
<i>( ... -- ... f )</i>.
<p>
Каждое следующее условие вычисляется только в том случае, если
результат еще не ясен (т.е. исполнение продолжается только если
<code>CAND</code> получает через стек истину, а <code>COR</code> — ложь).
<i>Услови</i>я вычисляются слева направо, приоритет операций
<code>CAND</code> и <code>COR</code> один и тот же.
	<p>
У Wil'а Baden'а слова <code>CAND</code> и <code>COR</code> назывались
<code>ANDIF</code> и <code>ORIF</code>. Эти имена представляются мне
неудачными, я никогда не могу вспомнить, что именно делают <code>ANDIF</code>
и <code>ORIF</code>, а вот смысл <code>CAND</code> и <code>COR</code>
вспоминается легко — это как <code>&&</code> и <code>||</code> в языке Си.
Недостатком имен <code>ANDIF</code> и <code>ORIF</code>
является то, что они, имея внутри себя <b>if</b>, не поглощают,
а модифицируют логическое значение.
Baden'а это, впрочем, не смущает — он запросто может написать и
<nobr><code>ANDIF ... EXIT THEN</code></nobr>, оставив читателя наедине
с этой головоломкой.
	<p>
	<a name="casewhile"></a>
	<h4>
Использование <nobr><code>CASE ... ESAC</code></nobr> для разрешения нескольких <code>WHILE</code>
	</h4>
Конструкция выглядит так:
	<p>
<pre>
CASE BEGIN ... WHILE ... WHILE ... WHILE ... AGAIN ESAC
</pre>
Немного непонятно, да? Давайте распишем:
<pre>
	CASE		( C: case-label )
	  BEGIN		( C: case-label dest )
		...
	  WHILE		( C: case-label orig1 dest )
		...
	  WHILE		( C: case-label orig1 orig2 dest )
		...
	  WHILE		( C: case-label orig1 orig2 orig3 dest )
		...
	  AGAIN		( C: case-label orig1 orig2 orig3 )
	ESAC		( C:  )
</pre>
Действительно, <code>ESAC</code> разрешает все недостроенные переходы вперед.
<code>ESAC</code> — это как несколько <code>THEN</code>.
Точнее, как <code>THEN</code> для всех <i>orig</i> выше отметки.
	<p>
Конструкция предложена W.Baden'ом в одном из сообщений из comp.lang.forth.
	<p>
	<a name="caseifif"></a>
	<h4>
Использование <nobr><code>CASE ... ESAC</code></nobr> для проверки нескольких условий в условном операторе без части "иначе"
	</h4>
Конструкция выглядит так:
	<p>
<tt>
CASE
 </tt><i>условие1</i><tt> IF
 </tt><i>условие2</i><tt> IF
...
 </tt><i>условиеN</i><tt> IF
 </tt><i>действия</i><tt> ESAC
</tt>
<p>
Чтобы выполнились <i>действия</i> необходимо, чтобы все
<i>услови</i>я оставили на стеке истину.
	<p>
	<a name="caseelesac"></a>
	<h4>
Использование <nobr><code>CASE ... ESAC</code></nobr> для проверки нескольких условий в условном операторе с частью "иначе"
	</h4>
Для того, чтобы указать действия, выполняемыетогда, когда одно из условий
неверно, используется слово <code>ELESAC</code>.
Конструкция выглядит так:
	<p>
<tt>
CASE
 </tt><i>условие1</i><tt> IF
 </tt><i>условие2</i><tt> IF
...
 </tt><i>условиеN</i><tt> IF
 </tt><i>действия-если-да</i><tt> ELESAC
 </tt><i>действия-если-нет</i><tt> THEN
</tt>
<p>
<i>действия-если-да</i> выполняются тогда, когда выполнены все <i>услови</i>я;
<br>
<i>действия-если-нет</i> выполняются тогда, когда хотя бы одно <i>условие</i> не выполнено.
<p>
Слово <code>ELESAC</code> определено как
<pre>
: ELESAC ( C: case-label orig1 ... origN -- orig-new )
	[COMPILE] AHEAD  2>R   [COMPILE] ESAC   2R>
; IMMEDIATE
</pre>
Здесь используется знание того, что роль стека компилятора играет стек данных,
и того, что размер значения <i>orig</i> на стеке — две ячейки.
Обратите внимание на сходство с <code>ELSE</code>:
<pre>
: ELSE ( orig1 -- orig2 )
	[COMPILE] AHEAD   CS-SWAP   [COMPILE] THEN
; IMMEDIATE
: ELSE ( orig1 -- orig2 )
	[COMPILE] AHEAD 2>R   [COMPILE] THEN   2R>
; IMMEDIATE
</pre>
С учетом сделанных выше предположений, эти два определения слова <code>ELSE</code> эквивалентны.
Нетрудно видеть, что <code>ELESAC</code> отличается от <code>ELSE</code> тем,
что в нем вызывается <code>ESAC</code> там, где в <code>ELSE</code>
вызывается <code>THEN</code>.
	<p>
Этимология слова <code>ELESAC</code>. В языке Алгол-68 имеется слово
<b>esac</b>, это записанное наоборот слово <b>case</b>.
Слово <b>elif</b> образовано как <b>else+if</b>.
По аналогии с и в память об Алголе-68, <b>elesac=else+esac</b>.
На самом деле в таком словообразовании ничего страшного нет:
в Советском Союзе <nobr><b>do ... od</b></nobr> для русской версии Алгола-68
вообще было переведено как <nobr><b>цк ... кц</b></nobr>, однако репрессирован
за это никто не был.
	<p>
Преимуществом конструкции <nobr><code>CASE ... IF ... IF ... ELESAC ... THEN</code></nobr>
над <nobr><code>CASE ... CAND ... ESAC IF ... ELSE ... THEN</code></nobr>
является то, что в первом случае вспомогательное логическое значение не
используется и, стало быть, сокращается число сущностей, о которых надо
думать и с которыми могут быть связаны ошибки.
	<p>
	<a name="jbrien"></a>
	<h3>
Временное снятие значений <i>orig</i> и <i>dest</i> со стека
	</h3>
J.Brien
предложил(а)
	<!--a href="xxjbxx.htm">предложил(а)</a-->
следующий простой механизм:
<pre>
\ Программа стандарта ANS Forth с зависимостями от окружения:
\ - компилирующие слова оставляют orig и dest на стеке данных;
\ - размер значений orig и dest - два элемента стека.
CREATE temp 2 CELLS ALLOT
: >: temp 2! ;   IMMEDIATE
: <: temp 2@ ;   IMMEDIATE
</pre>

Пример использования:
<pre>
: vvv
    DUP 2 AND
    IF
            DUP 1 AND
            IF
                    DUP 4 AND
                    IF
                          ." yes"
                    ELSE
                    >:
            THEN
    THEN
                          ." no"
                    <:
                    THEN
    .
;
</pre>
То же самое в записи "структуры управления справа"
(такая запись всегда более компактна и читается <nobr>не хуже —</nobr> если к ней
привыкнуть):
<pre>
: vvv
    DUP 2 AND                     IF
    DUP 1 AND             IF
    DUP 4 AND     IF
        ." yes"   ELSE >: THEN    THEN
        ." no" <: THEN
    .
;
</pre>
Понять такой пример можно только если отойти от понятия условного
оператора и вспомнить, что <code>IF</code> компилирует условный
переход вперед, <code>THEN</code> указывает адрес назначения такого перехода,
связь между ними осуществляется через значения <i>orig</i>,
а <code>ELSE</code> — это <nobr><code>AHEAD [ CS-SWAP ] THEN</code></nobr>.
	<p>
Если мы вспомним все это, становится понятным, что каждый <code>IF</code>
в случае неудачи проверки передает управления на соответствующий
<code>THEN</code> (в последнем примере <code>IF</code> располагается над
соответствующим ему <code>THEN</code>).
Фраза <nobr><code>ELSE :></code></nobr> компилирует безусловный переход
вперед и разрешает находящийся над ней <code>IF</code> в предыдущей строке;
значение <i>orig</i> прячется в переменной <code>temp</code>.
Фраза <nobr><code><: THEN</code></nobr> достает значение <i>orig</i> 
из переменной <code>temp</code> и разрешает соответствующую команду 
перехода вперед.
	<p>
<a name="tozzfrom"></a>
Мы определим слова<br>
<b><code>[>Z] </code></b><i>( C: ... orig|dest -- ... )</i> Спрятать <i>orig|dest</i>.
Слово с признаком immediate.<br>
<b><code>[Z>] </code></b><i>( C: ... -- ... orig|dest )</i> Достать ранее спрятанное
словом <code>[>Z]</code> значение <i>orig|dest</i>.
Слово с признаком immediate.
	<p>
Почему такое имя.
Z — последняя буква в алфавите, так что
<code>[>Z]</code> означает "запрятать подальше", а <code>[Z>]</code>,
соответственно, "вытащить оттуда".

	<p>
Реализация предполагает, что:
	<ul>
	<li>
в качестве стека компилятора используется стек данных;
	<li>
размер значений <i>orig</i> и <i>dest</i> — две ячейки;
	<li>
значения, помещаемые на стек компилятора другими структурами управления,
не привязаны к глубине стека компилятора;
	<li>
структуры управления не запоминают глубину стека.
	</ul>
На самом деле последнее предположение является достаточно серьезным
ограничением: некоторые реализации <nobr><code>CASE ... ENDCASE</code></nobr>
используют глубину стека для управления циклом, разрешающим ссылки вперед.
Понятно, что если структура управления написана в предположении,
что все изменения глубины стека связаны с нею и только с нею,
то правильно работать с <code>[>Z]</code> и <code>[Z>]</code> она не будет.
T32 <em>не использует</em> глубину стека для управления разрешением ссылок в
<code>ESAC</code> или других структурах управления.
В общем же случае для хранения значений <i>orig|dest</i> надо заводить
отдельный стек.
<pre>
\ file: Z.FTH

\ ANS Forth code snippet requiring ROLL and ?DO from CORE EXT
: -ROLL  DUP 0 ?DO DUP >R ROLL R> LOOP DROP ;

\ ANS Forth code snippet
\ with the environmental dependencies that:
\ - control-flow stack is the same as data stack
\ - orig's and dest's are two-cell values
\ - control-flow stack elements are not bound to stack depth
\ - control structures do not remember stack depth
: [>Z] ( C: ... orig|dest -- orig|dest ... )
        DEPTH 1- -ROLL
        DEPTH 1- -ROLL
; IMMEDIATE
: [Z>] ( C: orig|dest ... -- ... orig|dest )
        DEPTH 1- ROLL
        DEPTH 1- ROLL
; IMMEDIATE


\ ANS Forth code requiring [>Z] and [Z>] defined above

: vvv
        DUP 1 AND                              IF
        DUP 2 AND                        IF
        DUP 4 AND                  IF
          ." OK "       AHEAD [>Z]
                                   THEN  THEN  THEN
          ." NO "
                        [Z>] THEN
        U.
;

\ 1 vvv
\ NO 1  ok
\ 2 vvv
\ NO 2  ok
\ 4 vvv
\ NO 4  ok
\ 3 vvv
\ NO 3  ok
\ 7 vvv
\ OK 7  ok
\ 6 vvv
\ NO 6  ok
</pre>
С помощью этих слов слово <code>ELESAC</code> можно определить как
<pre>
: ELESAC    [COMPILE] AHEAD  [COMPILE] [>Z]  [COMPILE] ESAC  [COMPILE] [Z>]
; IMMEDIATE
</pre>

	<p>
	<a name="nodepth"></a>
	<h2>
Почему не стоит запоминать глубину стека компилятора
	</h2>
Некоторые структуры управления допускают произвольное число элементов,
например <nobr><code>CASE ... ENDCASE</code></nobr> допускает произвольное 
число частей <nobr><code>OF ... ENDOF</code></nobr>.
Одно из слов (чаще всего последнее, в нашем примере <code>ENDCASE</code>)
разрешает произвольное число ссылок вперед (или назад).
Разумеется, такая конструкция должна каким-то образом отличать
"свои" элементы стека управления от "чужих".
	<p>
Стандарт ANS Forth этого вопроса вообще не затрагивает, оставляя все вопросы
реализации на усмотрение разработчиков.
	<p>
Наиболее популярны два способа разметки стека — с помощью вспомогательных
значений и путем запоминания глубины стека компилятора.
	<p>
В стандарте ANS Forth имеется слово <code>CS-ROLL</code>.
Это слово позволяет поднять значение <i>orig|dest</i> из глубин стека
компилятора на вершину.
	<p>
Если структура управления, такая как <nobr><code>CASE ... ENDCASE</code></nobr>,
запоминает исходную глубину стека компилятора, последствия применения
<code>CS-ROLL</code> непредсказуемы. Точнее, до некоторой степени предсказуемы,
поскольку ясно,
что взамен "импортированного" из-под отмеченной глубины значения под отметкой
окажется одно из принадлежащих конструкции значений <i>orig|dest</i>.
Это приведет к появлению неочевидной ошибки.
	<p>
В случае же использования в качестве отметки положенного на стек компилятора
значения, отметка "опускается" вместе с остальными значениями.
Другое дело, что если размер отметки отличается от размера значения
<i>orig|dest</i> (например, отметка — целое число, а <i>orig</i> — адрес 
и число), пользоваться словом <code>CS-ROLL</code> нельзя.
С другой стороны, если мы знаем, что в качестве стека компилятора используется
стек данных и знаем размеры значений, мы можем пользоваться 
словом <code>ROLL</code> (стандарт рекомендует в таком случае
задокументировать сделанные предположения об архитектуре системы).
	<p>
Другим примером конструкции, нарушающей предположение о неизменности
расположения значений на стеке компилятора, являются слова
<a href="ctlflow.htm#tozzfrom"><code>[>Z]</code> и <code>[Z>]</code></a>.
	<p>
	<a name="done"></a>
	<h2>
<code>DONE</code>: еще один способ организации цикла с несколькими выходами
	</h2>

J.Brien предлагает следующий способ организации цикла с несколькими выходами:
<pre>
: DONE POSTPONE ELSE CS-SWAP ; IMMEDIATE
</pre>
Возможны следующие варианты использования:
	<ol>
	<li>
<pre>

	CASE
	 BEGIN
		...
		... IF .... DONE
		... IF .... DONE
		... IF .... DONE
		...
	 AGAIN
	ESAC
</pre>
После того, как выполняется код между словами <code>IF</code> 
и <code>DONE</code>, выполняется выход из цикла.
Для разрешения ссылок вперед используется
<nobr><code>CASE ... ESAC</code></nobr>.
	</li>
	<li>

<pre>

	BEGIN
		...
		... IF .... DONE
		... IF .... DONE
		... IF .... DONE
		...
	AGAIN
	THEN THEN THEN
</pre>
То же самое, но для разрешения ссылок вперед используются <code>THEN</code>.
	</li>
	<li>
<pre>

	BEGIN
		... IF .... DONE ...
	REPEAT
</pre>
Последний пример эквивалентен конструкции
<pre>
	BEGIN
		... 0= WHILE ...
	REPEAT
	....
</pre>
и отличие состоит только в подчеркивании того, что действия, обозначенные 
четырьмя точками, логически относятся к циклу.
	</li>
	</ol>

	<p>
	<a name="startemerge"></a>
	<h2>
Рекурсивный блок <nobr><code>START ... EMERGE</code></nobr></a>
	</h2>
Следует отметить, что:
	<ol>
	<li>
структуры управления не исчерпываются системами переходов
	<li>
стандарт ANS Forth не позволяет выйти за рамки систем переходов.
	</ol>
Примером структуры управления, которая не может быть реализована через
переходы, является рекурсивный блок <nobr><code>START ... EMERGE</code></nobr>.
(Другим примером является бэктрекинг (backtracking, метод откатов).)
Структура имеет вид:
	<p>
<code>
START </code><i>{</i><code> ... DIVE ... </code><i>}</i><code> ... EMERGE<br>
</code>
	<p>
Слова <code>START</code> и <code>EMERGE</code> обозначают границы блока,
<code>DIVE</code> обозначает рекурсивный вызов блока. Слово
<nobr><code>DIVE# </code><i>( C: ... "n" -- ... )</i></nobr> обеспечивает вызов
<i>n</i>-го объемлющего блока (<nobr><code>DIVE# 1</code></nobr> эквивалентно
<code>DIVE</code>).

	<p>
	<a name="startimpl"></a>
	<h3>
Реализация
	</h3>
<pre>
\ : (CALL)   R@ REF+ >R< REF@ >R ;
\ : (START)  R@ REF@ >R< REF+ >R ;
: START     ?COMP COMPILE (START) >MARK &lt;MARK 201 ; IMMEDIATE
: EMERGE    ?COMP 201 ?PAIRS CS-DROP COMPILE EXIT >RESOLVE ; IMMEDIATE

\ ищем #-ый набор ( <addr> forward <addr+refsize> backward 201 ),
\ при этом addr после (START)
: (DIVE#) ( an .. a1 # --> an a1 )
    DEPTH 5 >                                               IF
    DEPTH 5 - 1+ 1                                  DO
    ( an .. a1 # )                          CASE
    I PICK 201 =                            IF
    I 1+ PICK backward =                    IF
    I 3 + PICK forward =                    IF
    I 2 + PICK   I 4 + 1+ PICK REF+  =      IF
    I 4 + PICK REF- TOKEN@ ['] (START) =    IF
    1- DUP 0=                               IF          \ # -- счетчик
            DROP        ( одно значение сброшено!)
            COMPILE (CALL)
            I 1+ PICK   ( это значение номер i+2 )
            I 1+ PICK   ( это значение номер i+1 )
              &lt;RESOLVE
            UNLOOP EXIT                     ESAC    LOOP    THEN
    1 ABORT" more than nesting level" ;

: DIVE ?COMP 1 (DIVE#) ; IMMEDIATE
: DIVE# ( "n" -- )
        ?COMP
        S$GETWORD S$NUMBER? -1 <> ABORT" single number expected"
        D>S (DIVE#)
; IMMEDIATE
\ DIVE# n calls the n-th enclosing block.
\ DIVE# 1 is equivalent to DIVE .
</pre>
	<p>
	<a name="startrec"></a>
	<h3>
Пример 1 — рекурсия
	</h3>

Приведем пример на использование рекурсивного блока.
Слово <nobr><code>fib. </code><i>( i -- )</i></nobr>
распечатывает <i>i</i>-ое число Фибоначчи.
<pre>
: fib. START DUP 3 < IF DROP 1 EXIT THEN DUP 1- DIVE SWAP 2 - DIVE + EMERGE . ;
: tst 11 1 DO I fib. SPACE LOOP ;

DECIMAL tst
1  1  2  3  5  8  13  21  34  55  89  144  233  377  610  987   ok
</pre>
	<p>
	<a name="startaux"></a>
	<h3>
Пример 2 - замена вспомогательного определения
	</h3>
<PRE>
: ttt START R@ @ R> CELL+ >R EMERGE [ 6 , ] . ;
 ok
ttt
6  ok
</PRE>
В этом примере текст <nobr><code>START R@ @ R> CELL+ >R EMERGE</code></nobr>
играет роль слова <code>LIT</code>.
<pre>
: tttt LIT [ 6 , ] . ;
 ok
tttt
6  ok
: newLIT R@ @ R> CELL+ >R ;
 ok
: vvv newLIT [ 8 , ] . ;
 ok
vvv
8  ok
</pre>

<a name="btrk"></a>
	<h2>
Упоминание о бэктрекинге (backtracking)
	</h2>
Было бы неправильно совсем не упомянуть бэктрекинг в тексте с таким заголовком.
Однако обзор методов реализации бэктрекинга занял бы больше места, чем весь
остальной текст. Кроме того, бэктрекинг — вещь довольно специфическая.
Так что в этой версии этой статьи бэктрекинг не рассматривается совсем.
Отметим только, что для реализации бэктрекинга требуется манипулирование
адресами возврата.
	<p>
Приведем только несколько ссылок:
	<p>
<a href="http://www.zetetics.com/bj/papers/bnfparse.htm">
A BNF PARSER IN FORTH</a>
by
<a href="http://www.zetetics.com/bj/index.html">
Bradford J. Rodriguez, Ph.D.</a>
<p>
<a href="../BacFORTH-88/BF-diplom.html">
НОВЫЕ СТРУКТУРЫ УПРАВЛЕНИЯ В ЯЗЫКЕ FORTH</a> дипломная работа
<a href="../index.html">Гасаненко М.Л., к.ф.-м.н.</a>,
и <a href="../index.html#bacforth">другие статьи про
бэктрекинг</a>.


<hr>
<i>
М.Л.Гасаненко
</i>
	</body>
	</html>