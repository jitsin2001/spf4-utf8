<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.06 [en] (WinNT; I) [Netscape]">
   <TITLE>BacFORTH - дипломная работа</TITLE>
</HEAD>
<BODY>
<I>
<TT>Document: <B>Дипломная работа</B> Гасаненко М.Л. (ф-т ПМ-ПУ СПбГУ, 1992) </TT><BR>
<TT>Document History:</TT></I>
<BR><I><TT><B>??.06.1990</B> - работа сдана в печать, опубликована в 1993
г. как: Гасаненко М.Л. <B>Новые синтаксические конструкции и бэктрекинг
для языка Форт.</B>//Проблемы технологии программирования - СПб: СПИИРАН,
1992, с.148-162. (Выпуск сборника планировался в 1991 г., осуществлен в
1993 г.; в рецензиях статей в самом этом сборнике указаны данные Л.:ЛИИАН,
1991.)</TT></I>
<BR><I><TT><B>??.05.1992</B> - защищена дипломная работа</TT></I>
<BR><I><TT><B>02.06.1999</B> - преобразование в HTML с сохранением особенностей
оригинального текста.</TT></I>
<p>
<A HREF="BF-diplom.html#title" >Title</A> <br>
<A HREF="BF-diplom.html#conte" >Содержание</A> <br>
<A HREF="BF-diplom.html#begin" >Beginning of the text</A> <br>



<br>
<br>
<P><I><B>A note for non-Russian speakers.</B> The main ideas of this work
have been published as: Gassanenko, M.L. <B>BacFORTH: An Approach to New
Control Structures.</B> Proc. of the <B>EuroForth'94 </B>conference, 4-6
November 1994, Royal Hotel, Winchester, UK, p.39-41.</I>
<P>(c) М.Л. Гасаненко, 1999
<BR>(c) M.L.Gassanenko, 1999
<P>Предупреждаю, что программирование на стековой машине с механизмом
откатов требует специфических навыков, это можно сравнить с изучением Форта
с самого начала. С другой стороны, мы пишем на Форте, и BacFORTH (на
Бэкфорте) тоже писать можно. На мой взгляд, это удобнее, чем просто Форт.
Если что - свяжитесь со мной.
<P>Если появится возможность использования этой вещи в каких-либо 
проектах - я буду заинтересован в сотрудничестве.
<P>Мои адреса:
<BR>&nbsp;&nbsp;&nbsp; mlg@forth.org - писать следует сюда, но если меня
там нет, можно попробовать mlg@iias.spb.su, mlg@post.tepkom.ru, gml@ag.pu.ru.
<br>Не забывайте, что существуют отпуска и праздники!
<h3>Замечания 1999 года:</h3><BR>
<tt>
Слова ALLOC FREE PRED SUCC не обязательны в реализации.
<p>
Слово -- есть знак комментария \ , это связано с тем, что на ЭВМ
серии ЕС символов {|}\ не было или на клавиатуре, или на АЦПУ.
<p>
Конструкция *> ... <*> ... <*> ... <* называлась по-разному. Одно
время я использовал синтаксис { ... | ... | ... } , но сейчас стало
принято заключать в фигурные скобки локальные переменные, поэтому
я склоняюсь к синтаксису {| ... || ... || ... |} или даже
.{ ... .|. ... .|. ... }.
<p>
Отложенный cut полезен как средство создания своих ориентированных на 
задачу операторов отсечения: без него или можно обойтись, или же он 
используется настолько часто, что следует ввести специальную конструкцию.
<p>
<HR WIDTH="100%">
<A NAME="conte">

<A HREF="BF-diplom.html#title" >Title</A> <br>
<A HREF="BF-diplom.html#begin" >Beginning of the text</A> <br>
<A HREF="BF-diplom.html#intro" >Введение</A> <br>
<A HREF="BF-diplom.html#auxil" >Вспомогательные средства</A> <br>
<A HREF="BF-diplom.html#recur" >Рекурсивный блок</A> <br>

<A HREF="BF-diplom.html#simpl" >Простейшая реализация откатов</A> <br>
<A HREF="BF-diplom.html#gener" >Бoлeе общий случай (слова PRO и CONT )</A> <br>
<A HREF="BF-diplom.html#notes" >Стековая нотация</A> <br>
<A HREF="BF-diplom.html#start" >START-EMERGE как ловушка неуспеха</A> <br>
<A HREF="BF-diplom.html#xbackt" >Явное задание действий при откате</A> <br>
<A HREF="BF-diplom.html#recu2" >Рекурсивный блок с трассирующимся телом</A> <br>
<A HREF="BF-diplom.html#block" >Блок альтернатив</A> <br>
<A HREF="BF-diplom.html#struc" >Структурный оператор CUT</A> <br>
<A HREF="BF-diplom.html#defer" >Отложенный CUT</A> <br>
<A HREF="BF-diplom.html#negat" >Отрицание по неудаче и квантор общности</A> <br>
<A HREF="BF-diplom.html#rever" >Обратимые операции</A> <br>
<A HREF="BF-diplom.html#exten" >Расширение ядра системы</A> <br>
<A HREF="BF-diplom.html#texti" >Бэктрекинг в режиме текстовой интерпретации</A> <br>
<A HREF="BF-diplom.html#rush" >RUSH - выход и исполнение</A> <br>
<A HREF="BF-diplom.html#quan" >Переменные типа QUAN, допускающие обратимое присваивание</A> <br>
<A HREF="BF-diplom.html#imple" >Реализация системы BacFORTH</A> <br>
<A HREF="BF-diplom.html#resul" >Результаты и обсуждение</A> <br>
<A HREF="BF-diplom.html#concl" >Заключение</A> <br>
<A HREF="BF-diplom.html#app1" >Приложение 1</A> <br>
<A HREF="BF-diplom.html#app2" >Приложение 2</A> <br>
<A HREF="BF-diplom.html#app3" >Приложение 3</A> <br>
<A HREF="BF-diplom.html#refer" >Литература</A> <br>

<P>
</tt>
<P>
<HR WIDTH="100%">
<A NAME="title">
<BR>&nbsp;
<CENTER>
<H3>
<TT>САНКТ-ПЕТЕРБУРГСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ</TT></H3></CENTER>

<CENTER>
<H3>
<TT>Факультет прикладной математики - процессов управления</TT></H3></CENTER>

<CENTER>
<H3>
<TT>Кафедра технологии программирования</TT></H3></CENTER>

<P><BR>
<CENTER>
<H3>
<TT>ГАСАНЕНКО Михаил Леонидович</TT></H3></CENTER>

<P>&nbsp;
<BR>&nbsp;
<BR>&nbsp;
<BR>&nbsp;
<BR>&nbsp;
<CENTER>
<H1>
<TT>НОВЫЕ СТРУКТУРЫ УПРАВЛЕНИЯ В ЯЗЫКЕ FORTH</TT></H1></CENTER>

<P>&nbsp;
<BR>&nbsp;
<BR>&nbsp;
<CENTER>
<P><TT>Зав. кафедрой канд. ф.-м. наук доцент СЕРГЕЕВ Сергей Львович</TT>
<P><TT>Научный руководитель доктор ф.-м. наук проф. ТУЗОВ Виталий Алексеевич</TT>
<BR>&nbsp;
<BR>&nbsp;
<BR>&nbsp;
<P><TT>Санкт-Петербург</TT>
<BR><TT>- 1992 -</TT></CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<P>
<HR WIDTH="100%">
<A NAME="begin">
<BR>&nbsp;
<BR>&nbsp;
<BR>
<CENTER>
<H1>
<TT>Новые структуры управления в языке FORTH</TT></H1></CENTER>

<CENTER>
<H3>
<TT>M.Л.Гaсaнeнкo</TT></H3></CENTER>

<CENTER>
<H3>
<TT>Ленинградский Государственный Университет</TT></H3></CENTER>

<P><BR>
<P><TT>Система BacFORTH является расширением стандарта Форт-83. Она предоставляет
пользователю гораздо более мощный по сравнению с другими языками программирования
набор управляющих конструкций.</TT>
<BR><TT>Использование фортовского адресного интерпретатора нестандартным
способом позволило реализовать бэктрекинг предельно просто и эффективно.
Наряду со стандартными система включает следующие</TT>
<BR><TT>структуры управления:</TT>
<UL>
<LI>
<TT>суперциклы, заменяющие вспомогательные рекурсивные процедуры;</TT></LI>

<LI>
<TT>структурированный оператор CUT;</TT></LI>

<LI>
<TT>отложенный CUT (также структурный);</TT></LI>

<LI>
<TT>конструкции, осуществляющие преобразование булевского значения в успех/неуспех
;</TT></LI>

<LI>
<TT>конструкции, осуществляющие обратное преобразование ( успех/неуспех
в булевское значение );</TT></LI>

<LI>
<TT>конструкции, явно задающие действия при откате;</TT></LI>

<LI>
<TT>как и в Прологе, отрицание по неудаче и альтернативы ( прологовское
OR ).</TT></LI>
</UL>
<TT>Конструкция START...DIVE...EMERGE (суперцикл, безымянный рекурсивный
блок) позволяет программировать рекурсивные алгоритмы без использования
вспомогательных рекурсивных процедур.</TT>
<P><TT>Система позволяет совместно использовать процедуры-предикаты и логические
значения. Процедуры, работающие в режиме бэктрекинга, можно рассматривать
как абстрактные итераторы.</TT>
<BR>&nbsp;
<H2>
<TT>Перевод иностранных терминов</TT></H2>
<TT><I>backtracking </I>- 1. бэктрекинг (перебор с возвратом как метод);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2. бэктрекинг (перебор с возвратом как процесс);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3. бэктрекинг (как метод исполнения программы);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
4. откат, бэктрекинг (возврат при переборе).</TT>
<BR><TT><I>backtrackable </I>- трассирующийся ( в честь трассы, остающейся
на стеке откатов ).</TT>
<BR><TT><I>success </I>- успех.</TT>
<BR><TT><I>to succeed </I>- вырабатывать успех (термин "успешное завершение"
неудачен - вырабатывая успех, процедура откладывается, а не завершается).</TT>
<BR><TT><I>failure </I>- неуспех (неудача).</TT>
<BR><TT><I>to fail </I>- вырабатывать неуспех, завершаться неуспехом.</TT>

<A NAME="intro">

<H2>
<TT>Введение</TT></H2>
<TT>Как средство языка программирования бэктрекинг появился в языках ПЛЭНЕР
[7] и Prolog [8,10].</TT>
<P><TT>Бэктрекинг представляет собой метод организации перебора вариантов
в глубину и заключается в том, что в точке, где возможен выбор нескольких
вариантов, выбирается один из них, на специальном стеке оставляется точка
возврата и продолжается выполнение программы. Такая передача управления
вперед называется успехом. Если впоследствии оказывается, что рассматриваемый
вариант неудачен, то вырабатывается неуспех, смысл которого в том, что
делается откат назад, к последней точке возврата, где выбирается следующий
вариант. Если вариантов больше нет, то и там снова вырабатывается неуспех.
Таким образом, успех влечет дальнейшую проработку варианта, а неуспех -
отказ от этого варианта и возврат с целью рассмотреть другой. Разумеется,
данный метод организации перебора может быть использован не только для
организации поиска подходящих вариантов методом перебора. Бэктрекинг может
намного увеличить выразительную силу языка программирования и является
очень полезным средством.</TT>
<P><TT>Итак, допускается передача управления как вперед, так и назад. Передача
управления вперед называется успехом, a назад - неуспехом. Вырабатывая
успех, процедура может оставить на специальном стеке точку возврата. Этa
точка возврата содержит информацию, необходимую для возобновления процедуры
при откате. При откате управление передается на самую последнюю из имеющихся
на стеке точку возврата.</TT>
<P><TT>Режим бэктрекинга позволяет создавать обратимые процедуры, т.е.
процедуры, восстанавливающие при откате исходное состояние. Возможны два
подхода к их реализации. Первый - сохранить где-либо информацию об исходном
состоянии с тем, чтобы при откате восстановить его. Второй - выполнить
при откате обратные действия.</TT>
<P><TT>Слова, оставляющие точку возврата, условимся называть трассирующимися
(в честь трассы, остающейся на стеке откатов)</TT>
<P><TT>Трассирующаяся (backtrackable) процедура может вырабатывать значения,
удовлетворяющие определенному условию (вырабатывая успех для каждого из
этих значений), или проверять условие (вырабатывая успех, если оно истинно
). Процедуры первого типа будем называть генераторами, а второго - фильтрами.</TT>
<P><TT>В основу использования бэктрекинга в системах логического программирования
[10] положена следующая интерпретация: каждой процедуре соответствует условие.
Процедура вырабатывает успех, если условие выполняется. Если выполнение
возможно для нескольких случаев, она вырабатывает успех для каждого случая
(процедура вырабатывает успех несколько раз, каждый раз устанавливая одно
из состояний, при котором условие выполняется. В Прологе значения остаются
в переменных, фигурирующих в записи предиката, и присваивание им значений
можно рассматривать как установление определенного состояния). Таким образом
процедура может вырабатывать значения, удовлетворяющие условию, завершаясь
успехом для каждого из них. Успех последовательности процедур понимается
как признак того, что все условия, соответствующие процедурам, выполнены
(логическое И). Операция ИЛИ реализуется как конструкция, завершающаяся
успехом, когда любая из альтернатив-процедур (или альтернатив-последовательностей
процедур) завершается успехом. Обзор по логическому программированию можно
найти в работе Агафонова и др.[1]. Попытки дополнить возможностями Пролога
другие системы программирования предпринимались неоднократно; упомянем
здесь лищь работу Карлсона [5], где описывается использование метода успешных
продолжений для построения интерпретатора хорновских клозов средствами
Лиспа. В работах Чарльтона [11] и Родригеза [12,13,14] описывается нестандартное
использование механизма интерпретации шитого кода для обхода дерева решений
в задачах типа анализа образцов и при работе с системой правил в экспертной
системе. Для всех этих работ характерно использование вспомогательного
флажка, сигнализирующего об успехе проверки. В работах Родригеза [12,13]
механизм откатов не используется, если одна из альтернатив отрабатывает
успешно, то остальные не проверяются. В работах Чарльтона [11] и Родригеза
[14] для реализации механизма откатов в качестве стека откатов используется
фортовский стек данных, что не очень удобно. Ниже будет показано, что при
реализации механизма откатов можно обойтись и без вспомогательных данных,
используя только механизм интерпретации кода. Кроме того, описанные в [11,12,13,14]
системы являются средствами решения конкретных задач.</TT>
<P><TT>В данной работе описывается язык BacFORTH, сочетающий в себе как
общепринятые, так и новые структуры управления, в т.ч. средства организации
перебора с откатами (бэктрекинга) и управления этим перебором.</TT>
<P><TT>Описание языка Форт можно найти в книге [2] или же [3,4]. Выбор
этого языка объясняется тем, что это один из немногих машинно-независимых
языков, дающих доступ к структуре исполнимого кода и механизму его исполнения.</TT>

<A NAME="auxil">

<H2>
<TT>Вспомогательные средства</TT></H2>
<TT>При реализации описываемых здесь структур управления был использован
механизм динамической памяти, аналогичный переменным CONTROLLED языка PL/1.</TT>
<P><TT>Изначально заводится обычная фортовская переменная. Если она используется
как динамическая, то после размещения она будет содержать в поле параметров
адрес отведенной для нее области, состоящей из двух ячеек, первая из которых
будет содержать значение, а вторая - указатель на ранее отведенную область.</TT>
<BR><TT>: @@ ( V -> N ) @ @ ;</TT>
<BR><TT>: @! ( N V -> ) @ ! ;</TT>
<BR><TT>Здесь N обозначает значение, а V -адрес ячейки (напр. PFA переменной).</TT>
<BR><TT>ALLOC! ( N V -> ) разместить V с начальным значением N</TT>
<BR><TT>FREE ( V -> ) освободить переменную V . Область памяти переносится
в список свободных областей.</TT>
<BR><TT>FFREE ( V -> ) освободить все отведенные для переменной области
памяти.</TT>
<BR><TT>PRED ( A1 -> A2 ) перейти от адреса отведенной для переменной области
памяти (A1) к адресу ранее отведенной области (A2).</TT>
<BR><TT>Это механизм можно использовать для:</TT>
<BR><TT>1) отведения памяти под переменные при входе в процедуру;</TT>
<BR><TT>2) реализации списков;</TT>
<BR><TT>3) реализации стеков.</TT>
<P><TT>Слово @R определено на ассемблере. Его эквивалентное определение
на Форте может выглядеть так:</TT>
<BR><TT>: @R R> R> DUP 2+ >R @ SWAP >R ;</TT>
<BR><TT>С помощью этого слова системное слово LIT можно определить следующим
образом:</TT>
<BR><TT>: LIT @R ;</TT>
<BR><TT>Еще одно полезное слово - >R> - эквивалентно R> SWAP >R . Введен
еще один стек - L-стек, и на ассемблере определены слова для работы с ним:
L@ L> >L LDROP LP@ LP! , аналогичные словам для работы со стеком возвратов
R@ R> >R RDROP RP@ RP! .</TT>

<A NAME="recur">

<H2>
<TT>Cуперциклы вместо вспомогательных рекурсивных процедур</TT></H2>
<TT>Описываемая конструкция START...DIVE...EMERGE (суперцикл, [безымянный]
рекурсивный блок) позволяет программировать рекурсивные алгоритмы без использования
вспомогательных рекурсивных процедур.</TT>
<P><TT>Слова START и EMERGE ограничивают блок, а слово DIVE обеспечивает
его рекурсивный вызов. DIVE может встречаться несколько раз и находиться
внутри структур IF...THEN, BEGIN...UNTIL и т.д. Конструкция START...EMERGE
(без DIVE) эквивалентна использованию вспомогательной (нерекурсивной) процедуры
( после START на стеке возвратов остается адрес части, следующей за EMERGE,
EMERGE компилирует EXIT ).</TT>
<P><TT>Kонструкция</TT>
<BR><TT>START . . . DIVE . . . EMERGE</TT>
<BR><TT>эквивалентна (на PL/1)</TT>
<BR><TT>P:PROC; . . . CALL P; . . . END P; CALL P;</TT>
<BR><TT>точно также, как цикл BEGIN ... UNTIL эквивалентен</TT>
<BR><TT>L: . . . IF ... THEN GO TO L;</TT>
<P><TT>Помимо избавления от вспомогательных процедур, преимуществом этой
конструкции является то, что предотвращается разнос связанных по логике
программы операторов в разные части текста. (Действительно, удобнее, если
действия, выполняемые при инициализации перебора и после его окончания
записаны там же, где и тело.)</TT>
<P><TT>Для реализации суперцикла использованы следующие вспомогательные
слова:</TT>
<BR><TT>(START) - переносит скомпилированный за ним адрес на стек возвратов
и обходит этот адрес.</TT>
<BR><TT>(CALL) - кладет на стек возвратов адрес для возврата и совершает
переход по адресу, скомпилированному за ним.</TT>
<P><TT>: (START) R> DUP @ >R 2+ >R ;</TT>
<BR><TT>: (CALL) @R >R ;</TT>
<P><TT>Слова немедленного исполнения START , DIVE и EMERGE компилируют
слова (START) , (CALL) , EXIT и адреса за ними следующим образом:</TT>
<P><IMG SRC="imageI40.JPG" HEIGHT=68 WIDTH=517>
<BR><TT>Cлово DIVE можно использовать внутри структур IF ... THEN , DO
... LOOP и др. сколько угодно раз. Слова START и EMERGE должны быть парными.
Слово ?DIVE эквивалентно IF DIVE THEN , N?DIVE эквивалентно IFNOT DIVE
THEN . Cлово немедленного действия DIVE# , за которым должно следовать
число ( N ) позволяет вызвать N-й объемлющий блок ( DIVE# 1 эквивалентно
DIVE ).</TT>
<H4>
<TT>Пример.</TT></H4>
<TT>Данная программа распечатывает двоичное дерево, узлы которого находятся
в памяти и имеют следующий формат:</TT>
<CENTER><TABLE BORDER COLS=3 >
<TR>
<TD>
<CENTER><TT>&lt;значение></TT></CENTER>
</TD>

<TD>
<CENTER><TT>&lt;адр.левого поддер.></TT></CENTER>
</TD>

<TD>
<CENTER><TT>&lt;адр.правого поддер.></TT></CENTER>
</TD>
</TR>
</TABLE></CENTER>
<TT>0 в качестве адреса означает пустое поддерево.</TT>
<BR><TT>: PRINT ( адр-корня -> )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ?DUP IF ( не пусто ли дерево ? )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
START DUP 2+ @ ?DUP ?DIVE&nbsp; -- распечатать левое поддерево,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-- если оно не пусто</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DUP @ .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-- распечатать значение</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DUP 4 + @ ?DUP ?DIVE -- распечатать правое поддерево,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-- если оно не пусто</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
EMERGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THEN ." ;" CR
;</TT>
<BR><TT>Когда дерево распечатано, печатается ';' и выполняется CR .</TT>
<P><TT>Использование конструкции START-EMERGE без DIVE эквивалентно использованию
вспомогательной процедуры.</TT>
<BR><TT>Например,</TT>
<BR><TT>: 5. START @R EMERGE [ 5 , ] . ;</TT>
<BR><TT>эквивалентно</TT>
<BR><TT>: LIT @R ;</TT>
<BR><TT>: 5. LIT [ 5 , ] . ;</TT>
<BR><TT>( Напомним, что : @R R> R> DUP 2+ >R @ SWAP >R ; )</TT>
<A NAME="simpl">

<H2>
<TT>Простейшая реализация откатов</TT></H2>
<TT>Как известно, шитый код представляет собой последовательность ссылок
на процедуры. Интерпретатор по очереди вызывает процедуры, соответствующие
ссылкам. В указателе интерпретации (IP) хранится указатель на следующую
ссылку. При вызове высокоуровневой процедуры выполняется вызов фрагмента
шитого кода, являющегося ее телом: текущее значение IP сохраняется на стеке
возвратов, после чего IP устанавливается на начало шитого кода вызываемой
процедуры. Для выхода из нее выполняется действие EXIT : IP загружается
значением, снимаемым со стека возвратов.</TT>
<P><TT>Слово ENTER вызывает фрагмент шитого кода, адрес которого лежит
на стеке:</TT>
<P><TT>: ENTER >R ;&nbsp;&nbsp; ( ';' компилирует EXIT )</TT>
<P><TT>Будем рассматривать сразу два уровня шитого кода (ШК). Имеем две
высокоуровневые процедуры: вызывающую и вызываемую. На вершине стека возвратов
- адрес оставшейся части ШК вызывающей</TT>
<BR><TT>процедуры. Основная идея реализации формулируется очень просто:
успех - это вызов продолжения; неуспех - возврат из продолжения. (В роли
продолжения выступает остаток шитого кода вызывающей процедуры.)</TT>
<BR><TT>Если вызываемая процедура выполнит код R@ ENTER , она осуществит
вызов остатка ШК вызывающей процедуры.</TT>
<P><TT>: SUCC COMPILE R@ COMPILE ENTER ; IMMEDIATE</TT>
<P><TT>Чтобы вызвать возврат из продолжения, т.е. из фрагмента ШК, процедура,
скомпилированная в него, должна выполнить RDROP EXIT .</TT>
<P><TT>: FAIL COMPILE RDROP COMPILE EXIT ; IMMEDIATE</TT>
<P><TT>Обратите внимание на то, что слово</TT>
<BR><TT>: FAILURE FAIL ;</TT>
<BR><TT>эквивалентно EXIT .</TT>
<BR>&nbsp;
<H4>
<TT>Пример.</TT></H4>
<TT>: //2 DUP 2 MOD 0= IF SUCC THEN FAIL ;</TT>
<BR><TT>-- успех, если число делится на 2</TT>
<BR><TT>: //3 DUP 3 MOD 0= IF SUCC THEN FAIL ;</TT>
<BR><TT>-- успех, если число делится на 3</TT>
<P><TT>: 1-10&nbsp;&nbsp;&nbsp;&nbsp; 1 BEGIN&nbsp;&nbsp;&nbsp;&nbsp; SUCC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DUP 10 &lt; WHILE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
REPEAT&nbsp; DROP FAIL ;</TT>
<BR><TT>: DIV2 1-10 //2 DUP . ;</TT>
<BR><TT>: DIV3 1-10 //3 DUP . ;</TT>
<BR><TT>: DIV6 1-10 //2 //3 DUP . ;</TT>
<P><TT>Слово 1SUCC иногда позволяет сэкономить одну ячейку в пространстве
шитого кода и один вызов во время исполнения :</TT>
<BR><TT>: 1SUCC COMPILE R> COMPILE ENTER ; IMMEDIATE</TT>
<H4>
<TT>Пример.</TT></H4>
<TT>: //3&nbsp;&nbsp; DUP 3 MOD 0=</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF&nbsp;&nbsp;&nbsp;&nbsp;
1SUCC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE&nbsp;&nbsp; FAIL
THEN ; -- FAIL после 1SUCC не нужен</TT>
<BR><TT>С помощью слова 1SUCC можно выработать успех только один раз. При
реализации слов SUCC и FAIL на ассемблере выигрыш практически не ощутим,
и единственное полезное свойство 1SUCC - то, что на стеке возвратов остается
только одно значение.</TT>
<P><TT>Итак,</TT>
<BR><B><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; стек откатов = стек
возвратов.</TT></B>
<A NAME="gener">

<H2>
<TT>Бoлeе общий случай (слова PRO и CONT )</TT></H2>
<TT>Если в определении процедуры использованы трассирующиеся (backtrackable)
слова, или даже цикл DO...LOOP, то слова SUCC и FAIL не будут работать.
Для этого случая предназначены слова PRO , переносящее адрес продолжения
на L-стек, и CONT , вызывающее успех с использованием этого адреса. Под
процедурой здесь будем понимать процедуру, в которую скомпилированы слова
PRO и CONT .</TT>
<P><TT>CONT (continue) - обеспечивает успех процедуры. После отката будет
выполнен код, скомпилированный за CONT . ( Oбратите внимание, что при откате
управление передается на последнюю точку возврата, а она установлена внутри
процедуры).</TT>
<P><TT>PRO (prologue,PROLOG) - обеспечивает работоспособность слова CONT
. Обычно это первое слово в определении. Оно переносит адрес продолжения
(по которому надо перейти при успехе) со стека возвратов на L-стек и оставляет
точку возврата, которая при откате снимает адрес продолжения с L-стека
и вызывает неуспех процедуры.</TT>
<P><TT>: PRO R> R> >L ENTER LDROP ;</TT>
<BR><TT>-- : PRO R> R> >L >R SUCC LDROP FAIL ;</TT>
<BR><TT>: CONT L> >R SUCC R> >L ;</TT>
<P><TT>Заметим, что словo</TT>
<BR><TT>: NEVER-SUCCEEDS PRO ;</TT>
<BR><TT>также эквивалентно EXIT .</TT>
<H4>
<TT>Пример.</TT></H4>
<TT>: 1-10&nbsp; PRO 11 1 DO&nbsp; I CONT DROP&nbsp; LOOP ;</TT>
<BR><TT>: //3&nbsp;&nbsp; PRO DUP 3 MOD 0=&nbsp; IF&nbsp; CONT&nbsp; THEN
;</TT>
<A NAME="notes">

<H2>
<TT>Общие замечания</TT></H2>
<TT>Действия трассирующегося (backtrackable) слова нельзя адекватно описать
состояниями стека до и после исполнения. Поэтому будем описывать такие
процедуры в виде:</TT>
<CENTER><I><TT>cocтояние стека до исполнения -> cocтояние стека после успеха</TT></I>
<BR><I><TT>cocтояние стека после неуспеха &lt;- cocтояние стека перед откатом</TT></I></CENTER>
<TT>Необходимо следить за балансом стека: cocтояние стека после неуспеха
не должно зависеть от того, завершалась процедура успехом или нет.</TT>
<P><TT>Наряду с записью</TT>
<CENTER>
<P><I><TT>до -> усп</TT></I>
<BR><I><TT>после &lt;- отк</TT></I></CENTER>

<P><TT>будем использовать запись</TT>
<CENTER>
<P><I><TT>( до -> усп / после &lt;- отк )</TT></I></CENTER>

<P><TT>или даже</TT>
<CENTER><I><TT>( до &lt;-> усп )</TT></I></CENTER>
<TT>если соответствующие cocтояния стека совпадают.</TT>
<P><TT>Трассирующуюся процедуру, перебирающую значения, принадлежащие соответствующему
множеству, можно считать абстрактным итератором. Может показаться необычным,
что такой процедуре - всего одному слову - нужно уделять столько же внимания,
сколько и циклу - структуре из нескольких слов. Практика программирования
на языке BacFORTH показала, что легче всего использовать слова вида ( сост1
&lt;-> сост2 ) или же ( сост1 -> сост2 / &lt;- ). В конце концов, если
манипуляции со стеком кажутся чересчур сложными, можно использовать обычные
переменные или переменные типа QUAN, возможно, с еще одним полем кода для
обратимого присваивания.</TT>

<A NAME="start">
<H2>
<TT>START-EMERGE как ловушка неуспеха</TT></H2>
<TT>При использовании в виде</TT>
<P><TT>START &lt;действия> EMERGE &lt;действия-после-неуспеха></TT>
<P><TT>после того, как &lt;действия> завершатся неуспехом, будет выполнена
часть, следующая за EMERGE. Скомпилированный код выглядит следующим образом:</TT>
<BR><IMG SRC="imageK2E.JPG" HEIGHT=59 WIDTH=400>
<BR><TT>После исполнения слова (START) адрес &lt;действий-после-неуспеха>
оказывается на стеке возвратов. Т.к. откат реализуется как возврат, после
неуспеха &lt;действий> управление попадет на &lt;действия-после-неуспеха>.</TT>
<H4>
<TT>Пример.</TT></H4>
<TT>: DIV6A START 1-10 //2 //3 DUP .</TT>
<BR><TT>EMERGE ." вот и все " CR ;</TT>
<BR><TT>Слово DIV6A работает так же, как и DIV6 , но дополнительно печатает
" вот и все ".</TT>

<A NAME="xbackt">

<H2>
<TT>Явное задание действий при откате</TT></H2>
<TT>Слова немедленного действия BACK и TRACKING используются в виде</TT>
<BR><TT>BACK &lt;действия-при-откате> TRACKING</TT>
<BR><TT>и компилируют код</TT>
<BR><IMG SRC="imageCSG.JPG" HEIGHT=42 WIDTH=337>
<BR><TT>При исполнении слово (CALL) положит адрес &lt;действий-при-откате></TT>
<BR><TT>на стек возвратов, устанавливая таким образом точку возврата.</TT>
<P><TT>При использовании в виде</TT>
<BR><TT>BACK &lt;действия> TRACKING R></TT>
<BR><TT>на стек данных будет положен адрес фрагмента шитого кода, который
выполняет &lt;действия> и завершается скомпилированым EXIT . Этот фрагмент
можно выполнить с помощью слова ENTER .</TT>
<BR>&nbsp;

<A NAME="backt">

<H2>
<TT>Backtrackable Recursive Block</TT></H2>


<A NAME="recu2">

<H2>
<TT>Рекурсивный блок с трассирующимся телом</TT></H2>
<TT>Конструкция</TT>
<P><TT>START PRO ... DIVE ... CONT EMERGE</TT>
<P><TT>является аналогом прологовской рекурсии</TT>
<P><TT>P :- ... , P, ... .</TT>
<P><TT>Разница между START PRO ... DIVE ... CONT EMERGE и START ... DIVE
... EMERGE в том, что в первом случае часть после DIVE выполняется после
успеха рекурсивного вызова, а во втором случае часть после DIVE выполняется
после возврата.</TT>
<P><TT>Данная конструкция использует L-стек примерно так же, как START-DIVE-EMERGE
использует стек возвратов.</TT>
<P><TT>Того же эффекта можно достичь, используя RECURSE в теле вспомогательной
трассирующейся процедуры.</TT>


<A NAME="block">

<H2>
<TT>Блок альтернатив</TT></H2>
<TT>Блок альтернатив выглядит таким образом:</TT>
<BR><IMG SRC="image53P.JPG" HEIGHT=106 WIDTH=352>
<BR><TT>Альтернативы блока по очереди выполняются, и блок вырабатывает
успех каждый раз, когда одна из альтернатив вырабатывает успех. Kогда альтернатива
завершается неуспехом, начинает выполняться следующая, и т.д.; после того,
как завершается неуспехом последняя альтернатива, весь блок завершается
неуспехом. ( Oбратите внимание, что при откате управление передается на
последнюю точку возврата, которая может быть установлена внутри альтернативы).
На использование других управляющих структур внутри альтернатив нет никаких
ограничений.</TT>
<P><TT>Слова *> , &lt;*> и &lt;* компилируют следующий код:</TT>
<BR><IMG SRC="image9VK.JPG" HEIGHT=224 WIDTH=516>
<BR><TT>Слово (START) кладет на стек возвратов адрес следующей альтернативы,</TT>
<BR><TT>обеспечивая, тем самым, передачу ей управления при откате.</TT>
<P><TT>В духе логического программирования можно трактовать текст</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *> A &lt;*> B &lt;*</TT>
<BR><TT>как</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A or B.</TT>
<P><TT>Другой способ реализации блока альтернатив -</TT>
<P><TT>START PRO&nbsp;&nbsp; START &lt;альтернатива#1> CONT EMERGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
START &lt;альтернатива#2> CONT EMERGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
. . . . .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
START &lt;альтернатива#N> CONT EMERGE</TT>
<BR><TT>EMERGE &lt;общие_действия></TT>
<P><TT>может быть неудобен прежде всего тем, что использует L-стек. Однако
это может обернуться и преимуществом; кроме того, вместо внутренних блоков
START-EMERGE можно использовать вспомогательные определения, что может
быть удобно в некоторых задачах.</TT>


<A NAME="struc">

<H2>
<TT>Структурный оператор CUT</TT></H2>
<TT>Все операторы CUT используются для уничтожения точек возврата, находящихся
на стеке возвратов. Слово CUT: отмечает на стеке возвратов начало отсекаемой
области. -CUT уничтожает все точки возврата, установленные после этой отметки.
Конструкция выглядит так:</TT>
<P><TT>CUT: &lt;действия> -CUT</TT>
<P><TT>Слово -NOCUT может использоваться в качестве пары для CUT: в случае,
если оказывается, что точки возврата уничтожать не надо. Возможна вложенность.
Синтаксический контроль при компиляции отсутствует, соответствие определяется
во время исполнения. Это позволяет использовать cut без ограничений внутри
других структур управления, например так:</TT>
<P><TT>CUT: . . . IF -CUT ELSE -NOCUT THEN</TT>
<P><TT>Teкст " CUT: P -CUT " можно трактовать как " Exists x:P(x) ". Oбратите
внимание, что после того, как P выработает успех, отката к P больше не
будет.</TT>

<A NAME="defer">

<H2>
<TT>Отложенный CUT</TT></H2>
<TT>Конструкция выглядит так:</TT>
<P><TT>CUT: . . . CUT&lt; . . . IF NOCUT! THEN . . . >CUT</TT>
<BR><TT>CUT: . . . NOCUT&lt; . . . IF CUT! THEN . . . >CUT</TT>
<P><TT>CUT: отмечает на стеке возвратов начало отсекаемой области.</TT>
<P><TT>CUT&lt; отмечает на стеке возвратов конец (предположительно) отсекаемой
области. При откате точки возврата (по умолчанию) будут уничтожены, если
не будет выполнен оператор NOCUT!.</TT>
<BR><TT>NOCUT&lt; отмечает на стеке возвратов конец (предположительно)
отсекаемой области. При откате точки возврата не будут уничтожены (по умолчанию),
если не будет выполнен оператор CUT!.</TT>
<BR><TT>CUT! указывает, что точки возврата на отмеченной области при откате
следует уничтожить. (Точка возврата слова NOCUT&lt; (или CUT&lt; , без
разницы) заменяется на точку возврата слова CUT&lt; .)</TT>
<BR><TT>NOCUT! аналогично указывает, что точки возврата на отмеченной области
уничтожать не следует. В итоге точки возврата уничтожаются или нет в соответствии
с последним CUT! или NOCUT! .</TT>
<P><TT>Слова ALWAYSCUT&lt; и NEVERCUT&lt; аналогичны словам CUT&lt; и NOCUT&lt;
, но в отличие от последних на них слова CUT! и NOCUT! не действуют, т.к.
они оставляют для них неверный адрес.</TT>
<P><TT>>CUT обозначает конец отложенного оператора cut.</TT>
<P><TT>Oператоры CUT могут быть вложенными, но есть ограничение: соответствующие
слова CUT: , CUT&lt; и >CUT должны быть вместе или внутри, или вне "обрубаемого"
участка.</TT>
<P><TT>Как и в случае обычного cut, снтаксический контроль при компиляции
отсутствует, и соответствие определяется во время исполнения.</TT>
<P><TT>Операторы CUT! и NOCUT! могут выдаваться по несколько раз, уничтожение
точек возврата будет или не будет производиться в соответствии с последним
из них.</TT>
<H4>
<TT>Пример.</TT></H4>
<TT>Процедура P вырабатывает успех, если A,B и C,D - одна и та же пара
чисел, может быть в другом порядке</TT>
<P><TT>: P PRO ( A B C D &lt;-> A B A B )</TT>
<BR><TT>CUT: *> NOCUT&lt;</TT>
<BR><TT>&lt;*> SWAP BACK SWAP TRACKING NEVERCUT&lt; &lt;*</TT>
<BR><TT>2OVER 2OVER D= IF CUT! CONT THEN ;</TT>
<P><TT>Использование NOCUT&lt; в 1-ой альтернативе предотвращает повторный
успех, если на стеке лежит A A A A .</TT>

<A NAME="negat">

<H2>
<TT>Отрицание по неудаче и квантор общности</TT></H2>
<TT>Конструкция</TT>
<P><TT>NOT: P -NOT</TT>
<P><TT>вырабатывает успех, если P завершается неуспехом, ни разу не выработав
успеха. Если P вырабатывает успех, все точки возврата, установленные P
, уничтожаются и конструкция завершается неуспехом. На месте P может быть
любой осмысленный текст.</TT>
<P><TT>В зависимости от того, проверяет ли P условие или перебирает элементы
некоторого множества, успех " NOT: P -NOT " можно трактовать как " not
P(x) " или " not Exists x:P(x) ".</TT>
<P><TT>Квантор общности, выраженный через отрицание, записывается таким
образом:</TT>
<P><TT>ALL &lt;перебор_элементов_множества> ARE &lt;условие> OTHER &lt;действия>
WISE</TT>
<P><TT>и компилирует код:</TT>
<BR><IMG SRC="imageURA.JPG" HEIGHT=111 WIDTH=531>
<BR><TT>Действия между OTHER и WISE , как правило, необходимы для баланса
стека. Если процедура P генерирует значения, удовлетворяющие условию p,
а процедура Q проверяет условие q, успех ALL P ARE Q ... OTHER ... WISE
можно понимать как ДЛЯ_ВСЕХ x из {x:p(x)} q(x) .</TT>
<P><TT>Преобразование логического значения в успех/неуспех и наоборот.
Цикл FOREVER</TT>
<P><TT>Слово ONTRUE завершается неуспехом, если значение на стеке - ложь</TT>
<P><TT>: ONTRUE IFNOT FAIL THEN ;</TT>
<P><TT>Слово ONFALSE завершается неуспехом если значение на стеке - истина</TT>
<P><TT>: ONFALSE IF FAIL THEN ;</TT>
<P><TT>Oбратите внимание, что эти слова не оставляют точек возврата.</TT>
<P><TT>Для этих слов существует также и альтернативный синтаксис:</TT>
<P><TT>ONTRUE ?</TT>
<BR><TT>ONFALSE N?</TT>
<P><TT>Эти слова используются очень часто, в том числе и в качестве условного
оператора до конца определения. Для этих же целей служат и слова</TT>
<BR><TT>?/DROP ( a f -> a / &lt;- )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
?/2DROP ( aa f -> aa / &lt;- )</TT>
<BR><TT>?/NIP ( a b f -> a b / b &lt;- b ) ?/2NIP ( aa bb f -> bb &lt;-
bb )</TT>
<BR><TT>N?/DROP ( a f -> a / &lt;- )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
N?/2DROP ( aa f -> aa / &lt;- )</TT>
<BR><TT>N?/NIP ( a b f -> a b / b &lt;- b ) N?/2NIP ( aa bb f -> bb &lt;-
bb )</TT>
<BR><TT>Приведем пример одного из них:</TT>
<P><TT>: ?/DROP IFNOT DROP FAIL THEN ;</TT>
<BR><TT>: ?/DROP ONFALSE DROP FAIL ;</TT>
<P><TT>Конструкция PREDICATE . . . SUCCEEDS кладет на стек истину, если
текст между PREDICATE и SUCCEEDS вырабатывает успех ( в этом случае точки
возврата уничтожаются), и ложь в противном случае. Точно также конструкция
PREDICATE . . . FAILS кладет на стек истину, если текст между PREDICATE
и FAILS завершается неуспехом.</TT>
<P><TT>Oбратите внимание, что возможна следующая конструкция:</TT>
<BR><TT>['] P PREDICATE EXECUTE SUCCEEDS IF . . .</TT>
<BR><TT>Слово FOREVER при откате каждый раз вырабатывает успех, позволяя
организовывать бесконечные циклы. Впрочем, из такого цикла можно выйти,
используя CUT .</TT>
<P><TT>: FOREVER BEGIN SUCC AGAIN ;</TT>


<A NAME="rever">

<H2>
<TT>Обратимые операции</TT></H2>
<TT>Слова</TT>
<BR><TT>BDUP ( A &lt;-> A A ) ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
BDROP ( A &lt;-> ) ,</TT>
<BR><TT>BPRESS ( A B &lt;-> B ) ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
BSWAP ( A B &lt;-> B A ) ,</TT>
<BR><TT>B2DUP ( A B &lt;-> A B A B ) ,&nbsp;&nbsp; B2DROP ( A B &lt;->
) ,</TT>
<BR><TT>B2PRESS ( A B C D &lt;-> C D ) , B2SWAP ( A B C D &lt;-> C D A
B )</TT>
<BR><TT>отличаются от соответствующих стандартных тем, что при откате выполняют
обратные действия.</TT>
<P><TT>Слово B! ( N V -> / &lt;- ) работает как ! , но при откате восстанавливает
значение переменной. Слово BC! - это обратимое C! .</TT>
<BR><TT>Слово KEEP ( V -> / &lt;- ) не меняет значения переменной, но восстанавливает
его при откате.</TT>
<P><TT>Слова</TT>
<BR><TT>DROPB ( -> / &lt;- A ) ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2DROPB ( -> / &lt;- A B ) ,</TT>
<BR><TT>PRESSB ( -> / B &lt;- A B ) ,&nbsp;&nbsp;&nbsp; 2PRESSB ( -> /
C D &lt;- A B C D ) ,</TT>
<BR><TT>SWAPB ( -> / B A &lt;- A B ) ,&nbsp;&nbsp; 2SWAPB ( -> / C D A
B &lt;- A B C D ).</TT>
<BR><TT>отличаются от соответствующих стандартных тем, что работают при
откате.</TT>
<P><TT>B&lt;smth> означает "backtrackable &lt;smth>" , а &lt;smth>B означает
"&lt;smth> when backtracking" ("&lt;smth> при откате").</TT>
<P><TT>Кроме того, на практике полезны еще две операции, не имеющие в Форте
прямых аналогов:</TT>
<BR><TT>RESTB ( a -> a / a &lt;- )</TT>
<BR><TT>2RESTB ( a b -> a b / a b &lt;- )</TT>
<H4>
<TT>Пример.</TT></H4>
<TT>Следующие определения почти эквивалентны: они различаются</TT>
<BR><TT>только числом значений, оставляемых на стеке возвратов.</TT>
<P><TT>: SWAPB PRO BACK SWAP TRACKING CONT ;</TT>
<BR><TT>: SWAPB PRO START CONT EMERGE SWAP ;</TT>
<BR><TT>: SWAPB PRO CONT SWAP ;</TT>
<BR><TT>: SWAPB SUCC SWAP FAIL ;</TT>
<BR><TT>: SWAPB 1SUCC SWAP ;</TT>

<A NAME="exten">

<H2>
<TT>Расширение ядра системы</TT></H2>
<TT>Слово VOCABULARIES по очереди выдает PFA всех словарей, имеющихся в
системе.</TT>
<BR><TT>: VOCABULARIES ( -> voc-pfa / &lt;- ) PRO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; VOC-LINK @ >R</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; BEGIN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R@ 8 - CONT -- выдать
PFA словаря</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R> @ DUP >R -- перейти
к следующему</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0= UNTIL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; RDROP ;</TT>
<BR><TT>Слово NAMES выдает по очереди NFA всех имен в данном словаре.</TT>
<BR><TT>: NAMES ( voc-pfa -> nfa / &lt;- ) PRO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; @ ( 1-ое nfa ) >R</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; BEGIN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R@ CONT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R> N>LINK @ DUP >R</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0= UNTIL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; RDROP ;</TT>
<BR><TT>При использовании многониточного хеширования (multi-thread hashing),
полезно также иметь слова</TT>
<BR><TT>V>THREADS ( voc-pfa -> thread / &lt;- ) и</TT>
<BR><TT>T>NAMES ( thread -> nfa / &lt;- ).</TT>
<BR><TT>Определение слова NAMES может выглядеть как</TT>
<BR><TT>: NAMES ( voc-pfa -> nfa / &lt;- ) PRO V>THREADS T>NAMES CONT ;</TT>

<A NAME="texti">

<H2>
<TT>Бэктрекинг в режиме текстовой интерпретации</TT></H2>
<TT>В режиме текстовой интерпретации переменная >IN играет роль указателя
интерпретации (IP). Для поддержки бэктрекинга в режиме текстовой интерпретации
служит слово -> . Оно сохраняет >IN и вырабатывает успех; при откате оно
восстановит значение >IN .</TT>
<P><TT>Входной поток :</TT>
<P><TT>&nbsp;&nbsp;&nbsp; bслово -> слово2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a1&nbsp;&nbsp;&nbsp;&nbsp; a2 a3&nbsp;&nbsp;&nbsp;&nbsp;
a4</TT>
<P><TT>: -> STATE @ ONFALSE -- во время компиляции ничего не делает</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; PRO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; >IN @ >R&nbsp;&nbsp;&nbsp;&nbsp;
-- теперь >IN содержит a3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
BACK R> 3 - >IN ! -- записать a2 в >IN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
TRACKING</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
CONT ;</TT>
<BR><TT>-- :d INTERPRET</TT>
<BR><TT>-- BEGIN BL WORD FIND DUP IF</TT>
<BR><TT>-- 0&lt; STATE @ AND IF ,</TT>
<BR><TT>-- ELSE EXECUTE THEN</TT>
<BR><TT>-- ELSE DROP 1NUMBER [COMPILE] LITERAL</TT>
<BR><TT>-- THEN ?STACK AGAIN ;</TT>
<BR><TT>-- :d ("defined") использовано вместо : чтобы подчеркнуть, что</TT>
<BR><TT>-- мы только предполагаем, что слово определено таким образом;</TT>
<BR><TT>-- если мы даже введем такое определение, то система все еще</TT>
<BR><TT>-- будет использовать старое определение.</TT>
<P><TT>Для выхода из INTERPRET мой Forth использует "пустое" слово, эквивалентное
EXIT . Eго можно определить как</TT>
<P><TT>: X RDROP ; IMMEDIATE 0 LATEST 1+ C!</TT>
<P><TT>Как и EXIT , это слово всегда завершается неуспехом и вызывает откат.</TT>
<P><TT>Например, мы хотим знать, сколько слов в словаре FORTH.</TT>
<P><TT>0 ' FORTH >BODY NAMES -> DROP 1+ &lt;return></TT>
<BR><TT>. &lt;return></TT>
<BR><TT>252</TT>
<P><TT>Tаким образом можно тестировать слова "вручную", без вспомогательных
тестовых процедур.</TT>


<A NAME="rush">

<H2>
<TT>RUSH - еще одно полезное слово</TT></H2>
<TT>Трассирующиеся слова очень чувствительны к содержимому стека возвратов:
на вершине должен быть адрес куда-идти-если-успех, a вторым элементом должен
быть адрес куда-вернуться. Поэтому, если мы определим</TT>
<BR><TT>: WORK 0&lt; STATE @ AND IF , ELSE EXECUTE THEN ;</TT>
<BR><TT>: INTERPRET</TT>
<BR><TT>&nbsp; BEGIN BL WORD FIND DUP IF&nbsp;&nbsp;&nbsp;&nbsp; WORK (
!!! )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ELSE&nbsp;&nbsp; DROP 1NUMBER [COMPILE] LITERAL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
THEN ?STACK</TT>
<BR><TT>&nbsp; AGAIN ;</TT>
<BR><TT>то с таким интерпретатором трассирующиеся слова будут работать
совсем не так, как того следовало бы ожидать. На самом деле адрес куда-идти-если-успех
будет адресом скомпилированного в слове WORK слова EXIT. Если мы, например,
хотим выполнить обратимое присваивание, то обратное присваивание будет
выполнено немедленно, и никакого заметного результата мы не получим.</TT>
<P><TT>Во многих cлучаях слово RUSH эквивалентно EXECUTE EXIT (а именно,
если ему передано CFA обычного фортовского слова без RDROP-ов). Как и EXIT
, оно загружает (pop) IP со стека возвратов, после чего работает как EXECUTE
. Это слово позволяет избавиться от лишнего значения на стеке возвратов.
Определить его стандартными средствами Форта невозможно.</TT>
<P><TT>Таким образом, если мы определим</TT>
<BR><TT>: WORK 0&lt; STATE @ AND IF , ELSE RUSH THEN ;</TT>
<BR><TT>тогда INTERPRET будет подерживать бэктрекинг.</TT>
<P><TT>Слово RUSH> работает только если cкомпилированo:</TT>
<BR><TT>: RUSH> R> @ RUSH ;</TT>
<BR><TT>( На EXIT , скомпилированный ; , управление никогда не попадает
)</TT>
<BR><TT>RUSH> &lt;smth> эквивалентно ['] &lt;smth> RUSH .</TT>
<BR><TT>Oбратите внимание, что EXECUTE можно определить как</TT>
<BR><TT>: EXECUTE RUSH ;</TT>
<BR><TT>Кроме того, RUSH эквивалентно RUSH> EXECUTE и может быть определено
как</TT>
<BR><TT>: RUSH RDROP RUSH> EXECUTE ;</TT>
<BR><TT>EXIT эквивалентно RUSH> NOOP .</TT>

<A NAME="quan">


<H2>
<TT>Переменные типа QUAN, допускающие обратимое присваивание</TT></H2>
<TT>Следующие два примера приводятся в основном для того, чтобы проиллюстрировать
полезность конструкции START-EMERGE , но также и потому, что полезно иметь
удобный синтаксис для создания слов, определяющих слова с несколькими полями
кода.</TT>
<P><TT>Переменные типа QUAN были впервые описаны в работе [15], наиболее
распространенная в СССР реализация описана в [2]. Одна из проблем, возникающих
при реализации определяющих слов для слов с несколькими полями кода, состоит
в том, что слово DOES> , изменяющее поле кода, должно вызывать выход из
исполняемого фрагмента шитого кода определяющего слова. В [2] эта проблема
решается с помощью вспомогательных определений, от которых можно избавиться,
используя START-EMERGE.</TT>
<H4>
<TT>Вариант 1.</TT></H4>
<TT>: CF>> LATEST NAME> HERE OVER - OVER CFL + SWAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CFL ALLOT CMOVE> ;&nbsp;&nbsp;&nbsp;&nbsp;
-- добавить еще одно поле кода</TT>
<BR><TT>: ,DOES> COMPILE CF>> [COMPILE] DOES> ; IMMEDIATE</TT>
<P><TT>: CFA CREATE IMMEDIATE 1- CFL * ,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOES> @ ' +</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STATE @ IF , ELSE RUSH THEN ;</TT>
<P><TT>: BQUAN CREATE 0 ,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; START DOES> PRO B! CONT EMERGE ( NOW )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; START ,DOES> CFL + EMERGE ( AT )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; START ,DOES> [ CFL 2 * ] LITERAL + ! EMERGE
( TO )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,DOES> [
CFL 3 * ] LITERAL + @ ; ( default )</TT>
<P><TT>2 CFA IS&nbsp;&nbsp;&nbsp;&nbsp; 3 CFA AT&nbsp;&nbsp;&nbsp;&nbsp;
4 CFA NOW</TT>
<P><TT>Использование этих переменных может выглядеть следующим образом:</TT>
<BR><TT>BQUAN V 8 IS V &lt;return></TT>
<BR><TT>: LLL 5 NOW V V . ; &lt;return></TT>
<BR><TT>V . LLL V . &lt;return></TT>
<BR><TT>8 5 8</TT>
<P><TT>Только что описанная реализация не слишком удобна из-за того, что
поля кода приходится определять, начиная с последнего. Поэтому опишем еще
одну реализацию аналогичного синтаксиса.</TT>
<H4>
<TT>Bариант 2:</TT></H4>
<TT>: COMPILE-DOES-INSTRUCTION DOES-CMD @ , ;</TT>
<BR><TT>-- системно-зависимое слово. В моем Форте с ITC (косв. шитым кодом)</TT>
<BR><TT>-- :d DOES> COMPILE (DOES>) DOES-CMD @ , ; IMMEDIATE</TT>
<BR><TT>-- :d (DOES>) R> LATEST NAME> ! ;</TT>
<BR><TT>: CFAS ( #cfas -> ) 1- CFL * ALLOT ;</TT>
<BR><TT>: (#DOES>) ( cfa# -> ) 1- CFL * LATEST NAME> + R> SWAP ! ;</TT>
<BR><TT>: #DOES> COMPILE (#DOES>) COMPILE-DOES-INSTRUCTION ; IMMEDIATE</TT>
<BR><TT>-- 1 #DOES> эквивалентно DOES></TT>
<P><TT>: CFA ?EXEC CREATE IMMEDIATE 3 CFAS ,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; START 1 #DOES> [ CFL 2* ] LITERAL +</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
@ 1- CFL * ' +</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
STATE @ IF , ELSE RUSH THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; EMERGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; START 2 #DOES> CFL + @ EMERGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; START 3 #DOES> EMERGE ;</TT>
<P><TT>2 CFA TO 3 CFA AT 4 CFA NOW</TT>
<P><TT>: BQUAN CREATE 4 CFAS 0 ,</TT>
<BR><TT>START DOES> [ CFL 3 * ] LITERAL + @ EMERGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; START TO TO #DOES> [ CFL 2 * ] LITERAL + ! EMERGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; START TO AT #DOES> CFL + EMERGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; START TO NOW #DOES> RUSH> B! EMERGE ;</TT>


<A NAME="imple">

<H2>
<TT>Реализация системы BacFORTH</TT></H2>
<TT>Изначально система была реализована на Форте-К580 на ТС7063 с прямым
шитым кодом и адресным пространством 32К. Позднее система была перенесена
автором на Форт для ЕС-ряд2, разработанный им же. Часть слов системы BacFORTH
была включена в ядро Форт-системы, другая часть хранится в виде исходного
текста и загружается при запуске (загрузка занимает около 5 сек. на ЕС1045
при не слишком большой загруженности машины). Эта Форт-система использует
косвенный шитый код; она использует не блочную систему, а обычные файлы
СВМ (форматов F и V) и работает с 32-разрядными значениями (что, в общем-то,
является отступлением от стандарта 83 года). Слова SUCC и FAIL в этой версии
реализованы как CODE-определения, а не как макрокоманды; на ассемблере
же определены и такие часто использующиеся слова, как PRO , (START) и т.п.
Текст ядра Форт-системы не приводится, поскольку это более 20000 строк
листинга и более 5000 строк исходного текста на ассемблере ЕС.</TT>


<A NAME="resul">

<H2>
<TT>Результаты и обсуждение</TT></H2>
<TT>В данной работе описаны система BacFORTH, обладающая новыми структурами
управления, и методика, позволяющая реализовать бэктрекинг предельно просто
и эффективно.</TT>
<P><TT>Для языка BacFORTH характерно сочетание бэктрекинга с общепринятыми
структурами управления. Здесь описана реализация бэктрекинга на основе
языка Forth. Другим языком, допускающим столь же легкую реализацию по этой
методике, является язык ассемблера (разумеется, с макропроцессором).</TT>
<P><TT>Основным мотивом при разработке системы BacFORTH было стремление
приблизить синтаксис языка программирования к понятиям, которыми оперирует
человек, разрабатывая программу. В результате процедуры языка BacFORTH
могут весьма точно выражать идеи перебора или проверки. Сходных результатов
можно было бы достичь с помощью макропроцессора, заменив принцип "успех
как вызов продолжения" на "успех как макроподстановка продолжения" или
используя параллелизм вместо бэктрекинга.</TT>
<P><TT>Несколько слов о языке Пролог. Несмотря на название, он не обеспечивает
программирование в терминах логики. Процедуры Пролога соответствуют условиям
только в первом приближении, выражая скорее, в зависимости от контекста,
идею проверки условия или перебора значений, удовлетворяющих условию, чем
самого условия. На примере отрицания хорошо видно, что Пролог, использующий
бэктрекинг, не обеспечивает адекватной семантики для логических понятий.
Таким образом, даже при условии соблюдения достаточно сильного предположения
о том, что язык логики может быть языком мышления программиста (или быть
близок к нему), Пролог вынуждает программиста пользоваться им как не слишком
удобным императивным языком. Бэктрекинг является удобным средством для
организации перебора вариантов, но плохо подходит на роль семантики языка
предикатов. В этом плане Пролог можно сравнить с транслятором формул FORTRAN,
который, во-первых, понимает не любые формулы, во-вторых, это и не формулы,
поскольку результат зависит от того, как считать, а "действительные числа"
не образуют поля и вообще операция сложения не коммутирует, и который имеет
довольно слабо развитые структуры управления, так что выкрутиться можно,
но сложно.</TT>
<P><TT>Предположим, что разработка программы осуществляется по следующей
схеме:</TT>
<BR><TT>1) Начальное осмысление задачи.</TT>
<BR><TT>2) Составление черновика. Алгоритм записывается на некотором неформальном
языке черновика, позволяющем быстро восстановить в памяти любой фрагмент
программы. Результатом является черновик программы на языке черновика и
на языке мышления в сознании программиста.</TT>
<BR><TT>3) Адаптация к возможностям языка программирования и перевод с
языка черновика и языка мышления на этот язык.</TT>
<BR><TT>4) Отладка. На этом этапе часто требуется быстрый перевод с языка
программирования на язык мышления и наоборот.</TT>
<BR><TT>Облегчение такого перевода может быть достигнуто как минимум двумя
способами :</TT>
<BR><TT>1) путем сближения понятий, используемых в языке программирования,
с используемыми программистом;</TT>
<BR><TT>2) за счет концентрации в одном месте логически связанных операторов.
Это позволит устанавливать соответствие между меньшим фрагментом программы
и меньшим объемом информации, находящейся в сознании программиста.</TT>
<BR><TT>BacFORTH позволяет сконцентрировать в одном месте операторы, ответственные
за такие элементы алгоритма, как, например, перебор или проверка условия,
делая программу более легко обозримой.</TT>
<P><TT>Сравним, например, запись на языке BacFORTH</TT>
<P><TT>&nbsp;&nbsp;&nbsp; START</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; перебор1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
BACK действия1 TRACKING</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
перебор2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
проверка-условия</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
действия</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; EMERGE</TT>
<P><TT>с эквивалентной записью в духе языка CLU [6]</TT>
<P><TT>&nbsp;&nbsp;&nbsp; FOR i IN итератор1 DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FOR j IN итератор2 DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
IF проверка-условия THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
действия</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
END</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; действия1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; END</TT>
<P><TT>Процедуру, вырабатывающую значения в режиме бэктрекинга, можно рассматривать
как абстрактный итератор или предельно лаконичный оператор цикла, ориетированный
на решаемую задачу. Процедуру, вырабатывающую успех или неуспех в зависимости
от проверяемого условия можно рассматривать как абстрактный оператор проверки
условия.</TT>
<P><TT>После того, как такая процедура написана и отлажена, программист
может, если сочтет нужным и возможным, абстрагироваться от ее реализации.
Ниже будет приведен пример, в котором такой итератор передается как параметр.</TT>
<P><TT>Конструкция START-DIVE-EMERGE также способствует концентрации логически
связанных операторов в одном месте. Помимо избавления от вспомогательных
процедур преимуществом этой конструкции является то, что предотвращается
разнос связанных по логике программы операторов в разные части текста.
(Действительно, удобнее, если действия, выполняемые при инициализации перебора
и после его окончания записаны там же, где и действия, организующие перебор.)
Использование конструкции START-EMERGE (без DIVE ) эквивалентно использованию
вспомогательной процедуры.</TT>
<P><TT>В алголоподобных языках START-DIVE-EMERGE скорее всего больше походила
бы на процедуру, чем на цикл. Впрочем, она, видимо, потеряет в этих языках
половину своей выразительной силы, т.к. они позволяют делать только то,
что было заранее предусмотрено их реализаторами.</TT>
<P><TT>Появление этой конструкции в этих языках позволило бы поднять вопрос
об объявлении вредными (considering harmful) вспомогательных рекурсивных
процедур, как это произошло с GOTO. START-DIVE-EMERGE не сможет заменить
нескольких взаимно-рекурсивных процедур, но в большинстве случаев ее будет
достаточно, точно так же как GOTO иногда оказываются полезными.</TT>
<P><TT>Предложены средства управления бэктрекингом, более мощные, чем в
языке Пролог. Предложенный структурный оператор cut мощнее, обычного прологовского
cut и remote cut в ESP [9]. Явное задание области отсечения делает его
более удобным в пользовании, чем существующие аналоги.</TT>
<P><TT>Сам по себе оператор "отложенный cut" предназначен для случая, когда
сложность программы начинает выходить за пределы способностей программиста.
При программировании на BacFORTH он используется очень редко; при программировании
же на Прологе, где приходится тащить за собой трассу из точек возврата,
он был бы очень полезен, и это чувствуется даже в сравнительно несложных
задачах. Отсутствие необходимости все время программировать только в режиме
бэктрекинга является преимуществом перед языком Пролог.</TT>
<P><TT>Структура BACK-TRACKING может быть выражена в терминах Пролога,
хотя такой прием будет не совсем честным, т.к. с точки зрения декларативной
семантики это не будет иметь смысла.</TT>
<P><TT>Конструкции BACK-TRACKING и START-EMERGE в качестве ловушки неуспеха
делают, по сути дела, одно и то же, но возможность использования любой
из них, на выбор, облегчает программирование, играя для человека роль смыслового
ударения.</TT>
<P><TT>Конструкция, выдающая логическое значение в зависимости от того,
была ли процедура завершена успешно, представляется весьма полезной. Обратите
внимание, что ее можно использовать в виде</TT>
<BR><TT>['] &lt;процедура> PREDICATE EXECUTE SUCCEEDS IF ...</TT>
<P><TT>Кроме того, в сочетании с этими средствами можно использовать и
классические структуры управления, предоставляемые Фортом.</TT>
<P><TT>Очевидно, что полученные результаты укладываются в рамки императивного
подхода.</TT>
<P><TT>BacFORTH полностью унаследовал гибкость Форта. Точку возврата, например,
можно убрать словом RDROP. Ниже приведен несколько более сложный пример.</TT>
<BR><TT>: 1-10 ( &lt;-> I ) PRO 11 1 DO I CONT DROP LOOP ;</TT>
<BR><TT>-- распечатать значения, выдаваемые итератором,</TT>
<BR><TT>-- группируя в пары.</TT>
<BR><TT>: PRINT-PAIRED ( iterator -> )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; BACK ." ( "</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; START BACK ." , "</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
BACK ." ) ; ( " DIVE TRACKING R></TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
TRACKING R></TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EMERGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TRACKING R></TT>
<BR><TT>&nbsp;&nbsp;&nbsp; -- на стеке лежит адрес фрагмента шитого кода,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; -- распечатывающего разделитель ( ", " или ")
; ( " )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; -- и кладущего на стек адрес фрагмента кода,
печатающего</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; -- следующий разделитель.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; BACK DROP ." ) . " CR TRACKING -- по окончании
вывести последний</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; -- разделитель и сбросить со стека адрес фрагмента
кода.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; SWAP EXECUTE -- запуск итератора</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SWAP ENTER SWAP -- распечатать
разделитель</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DUP . ;</TT>
<P><TT>' 1-10 PRINT-PAIRED &lt;return></TT>
<BR><TT>( 1 , 2 ) ; ( 3 , 4 ) ; ( 5 , 6 ) ; ( 7 , 8 ) ; ( 9 , 10 ) .</TT>
<P><TT>Возвращаясь к изложенному выше, заметим, что обеспечить возможность
такого рода изобретений при написании транслятора с алголоподобного языка
практически невозможно.</TT>
<P><TT>Слово PRO можно реализовать как слово немедленного действия, изменяющее
поле кода. Вряд ли это будет лучше, т.к. в этом случае возможности использования
этого слова будут ограничены. Например, START PRO . . . DIVE . . . CONT
EMERGE эквивалентно прологовской рекурсии.</TT>
<P><TT>BacFORTH работает гораздо быстрее, чем Пролог. Язык Пролог, имея
небольшой набор базовых выразительных средств, вынуждает выражать простые
вещи через более сложные и более общие. Сравнение с МПрологом на ЕС1045
показало, что BacFORTH работает, в зависимости от задачи, в 8-35 раз быстрее.
( Список - не лучшая замена для массива, и вряд ли здесь что-нибудь поможет.)</TT>
<P><TT>BacFORTH может быть реализован на базе Форт-системы, использующей
любую из разновидностей шитого кода.</TT>
<P><TT>Примечательно, что для реализации бэктрекинга потребовался всего
один дополнительный стек.</TT>
<P><TT>Все программы, написанные в стандарте Форт-83, сохраняют работоспособность
и в системе BacFORTH.</TT>
<P><TT>В качестве возможных областей применения сразу можно указать анализ
текстов, построение трансляторов, экспертных систем, задачи, решаемые перебором
вариантов, просто программы со сложной логической структурой.</TT>
<P><TT>На сегодня с помощью этой методики была написана только одна серьезная
программа - Форт-ассемблер для процессора Intel80386. В этом ассемблере
процедуры-предикаты используются для анализа формата операндов и в словах,
работающих с таблицей меток, используются итераторы. Полного набора управляющих
структур системы BacFORTH для этой задачи не потребовалось.</TT>

<A NAME="concl">

<H2>
<TT>Заключение</TT></H2>
<TT>Получен мощный набор выразительных средств, соединяющий в себе возможности
алголоподобных языков и языков логического программирования. Благодаря
использованию принципа "успех как вызов продолжения" стоимость успеха и
неуспеха ненамного больше стоимости вызова и возврата. Предложены средства
управления бэктрекингом, более мощные, чем в языке Пролог. Конструкция
START ... DIVE ... EMERGE позволяет записывать рекурсивные алгоритмы, не
вводя вспомогательных рекурсивных процедур.</TT>
<P><TT>Система BacFORTH соединяет в себе классические структуры управления
и механизм откатов (бэктрекинг).</TT>
<P><TT>Основным мотивом при разработке системы BacFORTH было стремление
приблизить синтаксис языка программирования к понятиям, которыми оперирует
человек, разрабатывая программу. В результате процедуры языка BacFORTH
весьма точно выражают идеи перебора или проверки и т.о. могут рассматриваться
как абстрактные итераторы или операторы проверки условия. Использование
изложенной здесь методики может облегчить создание программ со сложной
логической структурой, хотя и требует от программиста некоторых специфических
навыков.</TT>

<A NAME="app1">

<H2>
<TT>Приложение 1.</TT></H2>
<TT>Слово, приведенное здесь в качестве примера, было использовано в дизассемблере
для К580. Оно изменяет поле кода слова-команды ассемблера таким образом,
что это слово при вызове будет проверять, могло ли оно породить текущую
машинную команду.</TT>
<P><TT>-- формат поля кода:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;call>
&lt;address>&nbsp; - 1+2 bytes</TT>
<BR><TT>-- формат таблицы адресов</TT>
<BR><TT>-- для полей кода:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;asm-addr> &lt;dasm-addr></TT>
<BR><TT>: N>DASM ( CFA -> CFA ) DUP 1+ @ ( cfa addr )</TT>
<BR><TT>TBL 24 + TBL</TT>
<BR><TT>DO</TT>
<BR><TT>I @ OVER = IF -- адрес найден в таблице</TT>
<BR><TT>DROP I 2+ @ OVER 1+ ! -- изменить поле кода</TT>
<BR><TT>0 LEAVE THEN</TT>
<BR><TT>4 +LOOP DROP ;</TT>
<BR><TT>Аналогичное слово N>ASM выполняет обратную замену</TT>
<BR><TT>: N>ASM ( CFA -> CFA ) DUP 1+ @ ( cfa addr )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TBL 24 + TBL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
I 2+ @ OVER =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- адрес найден в таблице</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
IF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DROP I @ OVER 1+ ! -- изменить поле кода</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0 LEAVE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 4 +LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; DROP ;</TT>
<BR><TT>-- итого : 2 заголовка, 2 поля кода, 62 ссылки на процедуры в шитом
коде.</TT>
<P><TT>На BacFORTH это могло бы выглядеть так:</TT>
<P><TT>: TBLSCAN ( &lt;-> I ) -- просмотр таблицы</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TBL 24 + TBL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; DO I CONT DROP 4 +LOOP ;</TT>
<P><TT>: N>DASM ( CFA -> CFA ) DUP 1+ @ ( cfa addr )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; CUT: DROPB TBLSCAN ( cfa addr i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2DUP @ = ONTRUE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-- если адрес найден в таблице</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
PRESS 2+ @ OVER 1+ !&nbsp;&nbsp;&nbsp; -- изменить поле кода</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-CUT ;</TT>
<BR><TT>: N>ASM ( CFA -> CFA ) DUP 1+ @ ( cfa addr )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; CUT: DROPB TBLSCAN ( cfa addr i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2DUP 2+ @ = ONTRUE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-- если адрес найден в таблице</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
PRESS @ OVER 1+ !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- изменить поле
кода</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-CUT ;</TT>
<BR><TT>-- итого : 3 заголовка, 3 поля кода, 51 ссылка на процедуру в шитом
коде.</TT>

<A NAME="app2">

<H2>
<TT>Приложение 2 - Задача о 8 ферзях.</TT></H2>
<TT>: ARRAY ( lwb upb -> )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CREATE SWAP DUP , -
1+ HERE OVER ERASE ALLOT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOES> DUP @ - + 2+ ;</TT>
<BR><TT>1 8&nbsp; ARRAY A -- можно ли поставить на I строку?</TT>
<BR><TT>2 16 ARRAY B -- можно ли поставить</TT>
<BR><TT>-7 7 ARRAY C -- на диагонали?</TT>
<BR><TT>1 8&nbsp; ARRAY X -- X[I] где стоит ферзь на I строке</TT>
<BR><TT>: PRINT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 SPACES 9 1 DO I .
LOOP CR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9 1 DO&nbsp; I .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
9 1 DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
J I X C@ =</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
IF ." Ф " ELSE ." . " THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
I . CR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 SPACES 9 1 DO I .
LOOP CR ;</TT>
<P><TT>-- Собственно программа</TT>
<BR><TT>: LOOK-OVER-LINES ( &lt;-> I ) PRO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
9 1 DO I CONT DROP LOOP ;</TT>
<BR><TT>: MAY-BE-PLACED? ( J I &lt;-> J I ) PRO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; DUP A C@ ONTRUE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2DUP + B C@ ONTRUE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2DUP - C C@ ONTRUE&nbsp;&nbsp;&nbsp;&nbsp; CONT ;</TT>
<BR><TT>: PLACE ( J I &lt;-> J I ) PRO -- разместить ферзя в J столбце
на I строке</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 2DUP X BC!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 OVER A BC!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2DUP + B 0 SWAP BC!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2DUP - C 0 SWAP BC!&nbsp;&nbsp;&nbsp;&nbsp; CONT ;</TT>
<BR><TT>: QUEENS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 1 A 8 BLANK 1 B 15 BLANK -7 C 15 BLANK</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 1 BEGIN ( перебор столбцов )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
LOOK-OVER-LINES MAY-BE-PLACED? PLACE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
BDROP DUP 8 &lt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1+ BACK 1- TRACKING</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REPEAT PRINT ;</TT>

<A NAME="app3">

<H2>
<TT>Приложение 3 - Нестандартные слова и системная зависимость.</TT></H2>
<TT>IFNOT&nbsp;&nbsp;&nbsp;&nbsp; эквивалентно 0= IF</TT>
<BR><TT>RDROP&nbsp;&nbsp;&nbsp;&nbsp; : RDROP R> R> DROP >R ;</TT>
<BR><TT>PRESS&nbsp;&nbsp;&nbsp;&nbsp; : PRESS SWAP DROP ;</TT>
<BR><TT>LATEST&nbsp;&nbsp;&nbsp; ( -> nfa ) NFA последнего определенного
слова</TT>
<BR><TT>CFL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Code Field Length - длина
поля кода</TT>
<P><TT>Кроме того, предполагается, что адреса на стеке возвратов - 16-разрядные,
и</TT>
<BR><TT>: EXIT1 R> DROP ;</TT>
<BR><TT>эквивалентно EXIT .</TT>

<A NAME="refer">

<H2>
<TT>Литература</TT></H2>
<TT>[1] Агафонов В.Н., Борщев В.Б., Воронков А.А. Логическое программирование
в широком смысле (обзор). - В кн.: Логическое программирование, М.:Мир,
1988, стр. 298-366.</TT>
<P><TT>[2] Баранов С.Н., Ноздрунов Н.Р. Язык Форт и его реализации. Л.:Машиностроение,
1988.</TT>
<P><TT>[3] Броуди Л. Начальный курс программирования на языке Форт. М.:Финансы
и статистика, 1990.</TT>
<P><TT>[4] Бураго А.Ю., Кириллин В.А., Романовский И.В. Форт - язык для
микропроцессоров. Л.:Знание, 1989.</TT>
<P><TT>[5] Карлсон, М. Пролог средствами функционального программирования.
- В кн.: Язык Пролог в пятом поколении ЭВМ. М.:Мир, 1988, с.159-172.</TT>
<P><TT>[6] Лисков, Б., Гатег, Дж. Использование абстракций и спецификаций
при разработке программ. М.:Мир, 1989.</TT>
<P><TT>[7] Пильщиков В.Н. Язык Плэнер. М.:Наука, 1983</TT>
<P><TT>[8] Стерлинг, Л., Шапиро, Э. Искусство программирования на языке
Пролог. М.:Мир, 1990.</TT>
<P><TT>[9] Тикаяма Т. ESP - предварительная версия базового языка программирования
компьютеров пятого поколения. - В кн.: Язык Пролог в пятом поколении ЭВМ.
М.:Мир, 1988, с.17-32.</TT>
<P><TT>[10] Хоггер, К. Введение в логическое программирование. М.:Мир,
1988.</TT>
<P><TT>[11] Charlton, G. FOSM: A FOrth String Matcher. Proc. of the 1991
euroFORML Conf., 1991.</TT>
<P><TT>[12] Rodriguez, B. A BNF Parser in Forth. ACM SIGForth Newsletter,
vol.2, no.2, December 1990, p.13-18.</TT>
<P><TT>[13] Rodriguez, B. Pattern matching in Forth. Proc. of the 1989
FORML Conf., 1989.</TT>
<P><TT>[14] Rodriguez, B. J. Rules Evaluation through Program Execution.
Proc. of the 1990 Rochester Forth Conf., 1990, p.123-125.</TT>
<P><TT>[15] Rosen, E. High Speed, Low Memory Consumption Structures (QUAN
and VECT). Proc. of the 1982 FORML Conf., p.191-196.</TT>
<BR>&nbsp;
<BR>&nbsp;
<BR>&nbsp;
<BR>&nbsp;
< end of document >
</BODY>
</HTML>
