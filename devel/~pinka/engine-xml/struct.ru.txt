Введение

  Модель XInclude, XML Inclusions, закрепленная в спецификации W3C,
  предназначена для решения общей задачи объединения нескольких 
  XML документов в один. Правда, хорошей поддержкой XInclude мало
  какой xml-процессор может похвастать.

  Той же задаче -- по заданной общей структуре сгенерить один сплошной 
  документ, -- служит и программа-транслятор struct.xsl,
  реализованная на стандартном XSLT 1.0.



Объяснение

  Далее, xmlns:xi="http://forth.org.ru/2006/XML/Struct" -- пространство
  имен языка struct.xsl.
  Язык для задания структуры включает как слова, описывающие подстановку,
  так и слова, определяющие фрагменты для подстановки.

  Примеры
 
    <xi:include href="struct-test.xml"/>

    <xi:model name="M1">any model content</xi:model>

    <xi:include href="#M1"/>

    <xi:model name="M2">
      <div><xi:include href="#M1"/></div>
    </xi:model>

    <xi:include href="#M2"> 'M2' not found </xi:include>


  Элемент xi:include вызывает подстановку, заданную 
  атрибутом href (абсолютный или относительный URL)
  Если атрибут 'href' пуст, то в качестве ресурса выступает 
  содержимое элемента xi:include.

  Если заданный в 'href' URL начинается с решетки, то он трактуется как 
  внутренняя ссылка на именованный элемент xi:model в пределах предков 
  этого элемента include. Этот элемент xi:model разрешается(ищется) 
  по его атрибуту 'name' в соответствии с динамическим контекстом (dynamic scope).
  Если разрешить его не удалось, то принимается содержимое элемента include
  (как если бы 'href' был пуст).
  Если же искомый xi:model установлен, то далее он транслируется так,
  как если бы сам был в дереве элементом include, его вызвавшем.
  А именно: атрибут 'href' разрешается по тем же правилам, вплоть до того,
  что контекст поиска не содержит самого этого элемента xi:model 
  (как если бы он был xi:include, то его бы и не было в контексте поиска),
  а содержимое транслируется только когда 'href' пуст или его не удалось разрешить.

    Таким образом,
      <xi:model name="decor-top" href="#decor-top" >
        <img alt="default decoration top" src="decor-top1.png"/>
      </xi:model>

    это никакая не прямая рекурсия, а вызов (подстановка) 'предыдущего определения' ( как в Форте :),
    если оно есть, если же предыдущего нету, то срабатывает  указанная тут подстановка img.

    А таким образом:

      <xi:model name="decor-top">
        <xi:include  href="#decor-top"/> <!-- вначале подставляем предыдущий 'decor-top' -->
        <img alt="sub decoration top" src="sub-decor-top.png"/> <!-- потом добавляем к нему img -->
      </xi:model>

    доступно пред/пост расширение (аспектная парадигма связывания). 
    Здесь #decor-top тоже вызов предыдущего определения, а не текущего xi:model.
   'Предыдущее' -- это для транслятора предыдущее. А на самом деле оно 
    может являться параметром).

   
  Несколько слов о контексте разрешения внутренних ссылок 
  (который похож на стек словарей -- контекст поиска в форте).

    1. Не имеет значение, чем перемежаются и где располагаются
       сестринские элементы xi:model (т.е., имеющие одного родителя);
       имеет значение только их порядок.

    2. Среди сестринских одноименных элементов xi:model
       выбирается самый последний (в естественном порядке обхода дерева).

       Например:
       <div>
         <xi:include href="#A"/>

         <xi:model name="A">456 - some beyond text</xi:model>

         <xi:model name="A">3</xi:model>
         <xi:model name="A">2<xi:include href="#A"/></xi:model>
         <xi:model name="A">1<xi:include href="#A"/></xi:model>
       </div>

       Выведет (трансформируется в): <div>123</div>


    3. Среди одноименных элементов xi:model из разных 'поколений'
       выбирается элемент из ближайшего поколения предков,
       исходя из динамического контекста (т.е., точки подстановки, а не точки определения).

       <div1>
         <xi:model name="B">(B1)</xi:model>

         <xi:model name="A">
           <xi:model name="A">(local A)</xi:model>
           <xi:include href="#A"/><xi:include href="#B"/>
         </xi:model>

         <xi:include href="#A" />

         <div2>
           <xi:model name="B">(B2)</xi:model>
           <xi:model name="A">[<xi:include href="#A"/>]</xi:model>

           <xi:include href="#A"/>
         </div2>

       </div1>

       Дает: <div1>(local A)(B1)<div2>[(local A)(B2)]</div2></div1>
       См. также пример struct-test.xml


  AOP-связывание 

    Следующие определения эквивалентны:

      1.
      <xi:model name="A">
        <p>some content</p>
        <xi:include href="#A"/>
      </xi:model>

      2.
      <xi:model name="A" advice="before">
        <p>some content</p>
      </xi:model>

    Также, эквиваленты и следующие определения:

      1.
      <xi:model name="B">
        <xi:include href="#B"/>
        <p>some content</p>
      </xi:model>

      2.
      <xi:model name="B" advice="after">
        <p>some content</p>
      </xi:model>




Дополнение

  struct-pre.xsl служит для разрешения лишь внешних ссылок,
  нужен для обхода проблемы "порядка документов" в XSLT.


Дискуссия

  Стоит ли вариант "иначе" (если не найдено, ссылку не удалось разрешить)
  обрамлять в тег xi:fallback, как в XInclude ?

  Стоит ли вместо решетки в href (признака локального имени), использовать
  другой, отдельный атрибут для задания локального имени?


\ $Id$