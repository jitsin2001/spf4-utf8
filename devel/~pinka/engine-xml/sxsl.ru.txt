Simple XSL

  Язык для простого определения сложных XSLT-шаблонов, требующих динамический контекст
  (в XSLT 1.x для этого приходится вручную передавать переменную параметром в каждый темплейт,
  в 2.0 решается через  Tunnel Parameters -- http://www.w3.org/TR/xslt20/#tunnel-params).

  Кроме того, позволяет вызывать темплейты просто тегом по имени, типа <name/>
  и делает правильную подстановку в случае разметки <name> any xml </name>.
  Стандартный арсенал XSLT тоже доступен, в своем xmlns:xsl.
  Примеры --  ~pinka/fml/src/*.sxsl.xml

  Программы, заданные на этом языке, транслируются в обычный XSLT путем применения sxsl.xsl.

  Следующий шаг -- DXSL, динамический XSLT, должен позволять "динамически" формировать
  xpath в select, name в call-template, и т.п. Очевидно, ему потребуется 
  на один-два прохода больше :)


Особенности и ограничения

  В SXSL нет средств вычислить и подставить параметр в генерируемый темплейт 
  (например, значение name, в <xsl:call-template name=''/>).

  Пока не поддерживается упрощенное описание выхода в SXSL (аналог TransformAlias в XSLT).

  Имена авто-вызываемых темплейтов и слова языка SXSL в одном пространстве имен
  (поэтому, не должны пересекаться с def, yield, var, let, apply-templates, call-template).

  Получаемый в результате трансляции xsl-шаблон зачастую будет требовать XSLT 2.0,
  т.к. в XSLT 1.0 есть скверные ограничения, связанные с лексической областью видимости имен,
  как то, -- внутри переменной нельзя объявить переменную с именем, которое
  используется снаружи этой переменной в том же темплейте.

  SXSL не поддерживает include -- сборку из частей,
  т.к. в XSLT 1.0 есть трудность с порядком следования узлов из разных документов,
  -- на него никак нельзя повлиять и невозможно явно задать (в 2.0 решается через sequence).
  Поэтому, стоит использовать предварительную сборку средствами XInclude или struct-pre.xsl
  перед отдачей потока на обработку by SXSL.


\ $Id$