<?xml version="1.0" encoding="Windows-1251"?>
<?xml-stylesheet type="text/xsl" href="xhtml.xsl"?>
<book xmlns:f="http://forth.org.ru/ForthML/">
<!-- $Id$ -->

<title>Набор функций над простейшими строками</title>

<chapter id="pre"><title>Преамбула</title>
  <ol>
   <li>Строки представляются на стеке парами (addr u), где addr — адрес соответствующего
   блока данных, и u — длина этого блока данных в единицах адреса.
   Неопределенная ситуация возникает, если адрес блока данных есть 0, а длина отлична от 0.</li>
   <li>Все функции над строками должны соблюдать границу символа.</li>
   <li>Формальные определения данных функций не зависят от кодировки, не зависят от формата и размера символов,
   не зависят от правил сопоставления (collations), — но каждая конкретная реализация явно фиксирует
   эти характеристики. Соответственно, в системе могут быть несколько реализаций данных функций (например,
   разведеных по разным словарям).</li>
   <li>Для однобайтных кодировок пробельными символами являются таковые с кодом 0x20 и меньше.
   Для UNICODE-16 и UNICODE-32 набор пробельных символов требует уточнения.</li>
   <li>Оборот "подстрока непосредственно состоит из таких-то символов строки" означает,
   что символы подстроки расположенны по тем же самым адресам, что и соответствующие символы строки.</li>
   <li>Сигнатуры слов является полноправной частью определений и не дублируются текстом.</li>
  </ol>
</chapter>

<chapter id="deflist"><title>Формальные определения</title>

<def name="EQUAL" ds=" a1 u1 a2 u2 -- flag ">
   <p>Если строка (a1 u1) целиком сопоставляется со строкой (a2 u2), то flag есть TRUE, иначе flag есть FALSE.</p>
</def>
<def name="CONTAINS" ds=" a u a-key u-key -- flag ">
   <p>flag обозначает, содержит ли строка (a u) подстроку (a-key u-key).</p>
</def>
<def name="STARTS-WITH" ds=" a u a-key u-key -- flag ">
   <p>flag обозначает, начинается ли строка (a u) с подстроки (a-key u-key).</p>
</def>
<def name="ENDS-WITH" ds=" a u a-key u-key -- flag ">
   <p>flag обозначает, заканчивается ли строка (a u) подстрокой (a-key u-key).</p>
</def>
<def name="SUBSTRING-AFTER" ds=" a u a-key u-key -- a2 u2 ">
   <p>(a2 u2) — подстрока, непосредственно состоящая из всех тех символов строки (a u),
   которые следуют за первым появлением подстроки (a-key u-key) в этой строке (a u);
   если подстрока (a-key u-key) не встречается, то (a2 u2) есть (0 0).</p>
</def>
<def name="SUBSTRING-BEFORE" ds=" a u a-key u-key -- a2 u2 ">
   <p>(a2 u2) — подстрока, непосредственно состоящая из всех тех символов строки (a u),
   которые предшествуют первому появлению подстроки (a-key u-key) в этой строке (a u);
   если подстрока (a-key u-key) не встречается, то (a2 u2) есть (0 0).</p>
</def>
<def name="SPLIT-"
     ds=" a u a-key u-key -- a-right u-right  a-left u-left  true  |  a u false ">
   <p>Если строка (a u) содержит подстроку (a-key u-key), то
   возвращается подстрока (a-right u-right) как результат функции SUBSTRING-AFTER
   и подстрока (a-left u-left) как результат функции SUBSTRIGN-BEFORE — примененных к (a u a-key u-key);
   иначе возвращается (a u).</p>
</def>
<def name="SPLIT"
     ds=" a u a-key u-key -- a-left u-left  a-right u-right  true  |  a u false ">
   <p>Если строка (a u) содержит подстроку (a-key u-key), то
   возвращается подстрока (a-left u-left) как результат функции SUBSTRIGN-BEFORE,
   и подстрока (a-right u-right) как результат функции SUBSTRING-AFTER — примененных к (a u a-key u-key);
   иначе возвращается (a u).</p>
</def>
<def name="MATCH-HEAD" ds=" a u a-key u-key -- a-right u-right true | a u false">
   <p>Если строка (a u) начинается с подстроки (a-key u-key), то возвращается подстрока (a-right u-right)
   как результат применения функции SUBSTRING-AFTER к (a u a-key u-key); иначе возвращается (a u).
   </p>
</def>
<def name="MATCH-TAIL" ds=" a u a-key u-key -- a-left u-left true | a u false">
   <p>Если строка (a u) заканчивается подстрокой (a-key u-key), то возвращается подстрока
   (a-left u-left), непосредственно состоящая из всех тех символов строки (a u),
   которые предшествуют последнему появлению подстроки (a-key u-key) в этой строке (a u).
   </p>
</def>


<def name="FINE-HEAD" ds=" a u -- a1 u1 ">
   <p>Подстрока (a1 u1) непосредственно состоит из первого непробельного символа и всех
   последующих за ним символов строки (a u); если в данной строке нет непробельных символов,
   то (a1 u1) есть (a+u 0).
   </p>
</def>
<def name="FINE-TAIL" ds=" a u -- a u2 ">
   <p>Подстрока (a u2) непосредственно состоит из последнего непробельного символа
   и всех предшествующих ему символов строки (a u); если в данной строке нет
   непробельных символов, то (a u2) есть (a 0).
   </p>
</def>
<def name="SPLIT-WHITE-FORCE"
     ds=" a u -- a-left u-left  a-right u-right ">
   <p>Подстрока (a-left u-left) непосредственно состоит из всех тех символов
   строки (a u), которые предшествуют первому появлению пробельного символа,
   подстрока (a-right u-right) непосредственно состоит из всех тех символов
   строки (a u), которые следуют за подстрокой (a-left u-left).
   </p>
</def>
<def name="-SPLIT-WHITE-FORCE"
     ds=" a u -- a-left u-left  a-right u-right ">
   <p>Подстрока (a-right u-right) непосредственно состоит из всех тех символов
   строки (a u), которые следуют за последним пробельным символом,
   подстрока (a-left u-left) непосредственно состоит из всех тех символов
   строки (a u), которые предшествуют подстроке (a-right u-right).
   </p>
</def>
<def name="WORD|TAIL" ds=" a u -- a1 u1 a-rest u-rest ">
   <p>Результат композиции функций FINE-HEAD SPLIT-WHITE-FORCE</p>
</def>


<def name="TAIL" ds=" a u -- a1 u1 ">
   <p>Подстрока (a1 u1) непосредственно состоит из всех символов строки (a u)
   за исключением первого символа; если u есть 0, то u1 тоже 0.</p>
</def>
<def name="HEAD" ds=" a u -- a u1 ">
   <p>Подстрока (a u1) непосредственно состоит из первого символа строки (a u);
   если u есть 0, то u1 тоже 0.</p>
</def>
<def name="HEAD|TAIL" ds=" a u -- a u1 a2 u2 ">
   <p>Подстрока (a u1) есть результат функции HEAD и подстрока (a2 u2) есть
   результат функции TAIL — примененных к строке (a u).</p>
</def>
<def name="HEAD|TAIL-" ds=" a u -- a2 u2 a u1 ">
   <p>Подстрока (a2 u2) есть результат функции TAIL и подстрока (a u1) есть
   результат функции HEAD — примененных к строке (a u).</p>
</def>


<def name="SEARCH" ds=" a u a-key u-key -- a2 u2 true | a u false ">
   <p>Если строка (a u) содержит подстроку (a-key u-key), то
   возвращается подстрока (a2 u2), непосредственно состоящая из всех символов первого появления
   подстроки (a-key u-key) в строке (a u)
   и всех последующих символов этой строки (a u); иначе возвращается (a u).</p>
</def>
<def name="COMPARE" ds=" a1 u1 a2 u2 -- 0 | -1 | 1 ">
   <p>Если строка (a1 u1) целиком сопоставляется со строкой (a2 u2), то возвращается значение 0;
   если первый несопоставленный символ строки (a1 u1) предшествует в таблице символов
   соответствующему символу строки (a2 u2), то возвращается значение -1;
   иначе возвращается значение 1.
   Замечание: псевдосимвол "конец строки" предшествует любому другому символу в таблице символов.
   </p>
</def>

</chapter>

</book>