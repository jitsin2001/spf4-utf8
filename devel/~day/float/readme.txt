float.f Версия 2.32 для SP-FORTH 3.75
Якимов Д. А. ftech@mail.ru
==========================

Исходные тексты бесплатны для коммерческого и некоммерческого использования.
При использовании вы должны указать в документации, что используется именно
эта библиотека.

Запещается распространять эту библиотеку в бинарном или текстовом виде
в коммерческих форт пакетах!

Техническая поддержка осуществляется мною для ВСЕХ пользователей
по мере наличия свободного времени.

Перед работой с математической библиотекой рекомендуется внимательнейшим 
образом ознакомиться с этим документом.

Занимает около 9 килобайт в скомпилированном виде.
Но можно сократить до 4000-5000, если убрать малоиспользуемые функции и 
оптимизировать не по быстродействию, а по объему.
Работает в многопоточной среде.
Далее - сопроцессор - это математический процессор Intel 387 и выше.
Кому нужно описание I387 - дам, пишите - 400 кило текстовый файл.

- Компилирование по FLIT, всегда десятибайтное


За величиной арифметического стека следит сам сопроцессор.
Вам доступно только 6 регистров арифметического стека.
2 значения использует преобразование числа в строку и обратно.
Поэтому будьте аккуратны и не используйте больше 6 регистров.
Кроме того, все команды с логарифмами требуют еще один элемент стека.
Поэтому 2 верхних элемента `подстраховывают` Вас от неприятностей.

Слова F>D и F>DS - при переполнении формируют флаг `Недействительная 
операция` - см. выше.
Также не стоит брать логарифм от 0 или отрицательного числа.

Если FLITERAL не узнает число, хотя синтаксис верен, значит стоял флаг 
`недействительная операция` и недавно была допущена ошибка!!! Сопроцессор 
реинициализируется.

Алгоритмы преобразования не такие как у уважаемого Тарасова. Некоторые 
даже не похожи. Я предполагаю, что мои быстрее ;)
Но он очень помог мне своим описанием библиотеки float.f для 
СП-ФОРТа 2.02. Персональное спасибо ему.

Спасибо также А. Ю. Черезову за его замечательую ФОРТ-систему.
Без исходных текстов которой написание этой библиотеки было бы 
невозможным.

Замечания по согласованию со стандартом:

1. F. - расширить семантику - печать как чисел в виде с фиксированной 
   точкой, так и в научном формате.
   Если система счисления не десятичная, напечатать в десятичной.
   Переключать форматы словами PRINT-EXP и PRINT-FIX

2. Слова выравнивания ничего не делают


Стандартные слова описывать не буду - есть в стандарте, а сейчас времени 
мало.
Появилось много новых слов:

>FNUM ( F: r -- addr u )
         Очень важное слово.
         Дает строковое представление числа r в адрес addr и
         возвращает addr и длину строки числа.

FLOAT>DATA ( F: r -- u u w ) 
           Переносит с верхушки float стека 10 байтное число
           на стек данных. Это для того если не хватает float стека.
           Встречается крайне редко.
DATA>FLOAT - наоборот           

#EXP  ( -- u ) - дает экспоненту числа (не мантисса :)
                    
FCON-E -  переменная, содержащая `E` или `e` или 'd' или 'D' - символ экспоненты.
          
FABORT ( -- )
          - если были ошибки при вычислениях, то это слово делает 
            следующее:
              1. Выводит сообщение о текущей ошибке
              2. Инициализирует сопроцессор
              3. Вызывает ABORT
          - если ошибок не было, то ничего и не произойдет
            Рекомендую использовать как можно чаще.
FINF      - кладет на арифметический стек число `+бесконечность`
            Физически это не просто наибольшее максимальное число,
            а конкретно бесконечность. С++ это явно не поддерживает!!!
            Можно производить различные вычисления с бесконечностью.
            Попробуйте набрать:  FINF 1e4099 F- F.
            Вы получите все равно бесконечность.
            (1E4099 - наибольшее возможное число)
            Соответственно модифицированно и `F.`
2e 1e .e  - константы, определенные через ассемблер.

FLOAT-VER - печатает версию данной библиотеки

F-SIZE - переменная, содержащая длину текущего числового формата, в байтах.
         Оказывает влияние на FLOAT+ FLOATS FLIT, F,

FVALUE - аналог VALUE

FTO    - аналог TO

FFORM - переменная, содержащая количество цифр, выводящихся после запятой 
        словом `F.`
FFORM-EXP - 
        переменная, содержащая минимальное количество цифр в порядке 
        числа, выводящегося `F.`. Если указанных позиций не хватает, 
        добавляется необходимое количество. Знак не в счет.
?PRINT-EXP
        булевая переменная, указывающая - печатать с в научном виде, 
        или в виде с фиксированной точкой.
PRINT-EXP ( -- )
        устанавливает переменную ?PRINT-EXP
PRINT-FIX ( -- )
        сбрасывает переменную ?PRINT-EXP

GETFPUCW  ( -- n )
        возвращает значение регистра управления сопроцессором 

GETFPUSW ( -- n )
        возвращает слово состояние сопроцессора
FINT     ( F: r1 -- r2 )
        Округляет число на стеке в соответствии с текущим правилом 
        округления.
FSINGLE  ( -- )
        переключает на 32 - битный формат числа. Формат имеет значение 
        только в следующих словах F,  FLOAT+ FLOATS FLIT,
        Перед их использованием следует поставить нужный формат.
        По умолчанию - 64 битный формат. Не стоит увлекаться переключением 
        формата - можно допустить невнимательность...
FDOUBLE ( -- )
        переключает на 64 - битный формат числа.
FLONG ( -- )
       переключает на 80 - битный формат числа.
FINIT - инициализация сопроцессора. Все данные в арифметическом стеке 
        уничтожаются.
HIGH-INIT        
        Также инициализация переменных типа USER
        для нормального функционирования float
F>DEG   ( F: r1 -- F: r2 )
        Преобразует число из радиан в градусы. Точно и быстро.
F>RAD   ( F: r1 -- F: r2 )
        Преобразует число из градусов в радианы. Точно и быстро.
F>DS  - ( F: r -- D: n )
        Переносит целую часть числа на стек данных в 32 бита. 
        Округляет в соответствии с текущими правилами.
DS>F  - ( D: n -- F: r )
        Переносит целое 32-х битное число со стека данных на 
        арифметический стек.
F--DS - ( F: r -- F: r D: n )
         аналогично F>DS, только не переносит, а копирует.
?OF   ( -- n )
      Возвращает -1, если при последней арифметической операции было 
      переполнение и 0 если не было.
?ZE   ( -- n )
      Возвращает -1, если при последней арифметической операции было 
      деление на 0 и 0 если не было.
?IE   ( -- n )
      Возвращает -1, если при последняя арифметической операция была
      недействительной и 0 если не была.
      Недействительная, значит - произошла грубая ошибка.
      Если Вы долго думали и не знаете - в чем причина,
      в этом случае свяжитесь со мной и представьте вашу ситуацию на 
      стеках. Я попытаюсь бесплатно устранить эту ошибку.
F10X ( n -- F: r )
      берет со стека данных число и кладет на арифметический стек 10 в 
      этой степени. Число может быть отрицательным и нулем. Лучше чем 
      FALOG для целочисленных операций.
FLOG2 ( F: r1 -- F: r2 )
      логарифм по основанию 2.
F[LOG] ( F: r1 -- F: r2 )
      логарифм по основанию 10, округленный в соответствии с текущим 
      правилом.
TRUNC-MODE ( -- )
      устанавливает режим округления `к нулю`.
ROUND-MODE ( -- )
      устанавливает режим округдения `к ближайшему или четному`
UP-MODE ( -- )
      устанавливает режим округления `в сторону положительной бесконечности`.
LOW-MODE ( -- )
       устанавливает режим округления `в сторону отрицательной бесконечности`.
F10* ( F: r1 -- F: r2 )
      быстро умножает на 10
F10/ ( F: r1 -- F: r2 )
      быстро делит на 10
`F1+ ( F: r1 -- F: r2 )
      Прибавляет 1 к числу на арифметическом стеке, но не использует 
      дополнительных регистров. Работает медленнее, чем F1+
      Введено для удобства и повышения скорости работы некоторых команд.
`F1- ( F: r1 -- F: r2 )
      Аналогично F1+
F>ENV ( addr -- )
      переносит в область памяти addr всю служебную информацию 
      сопроцессора, НЕ включая регистры (28 байт). 
FENV> ( addr  -- )
      восстанавливает состояние сопроцессора из области памяти addr.
FSAVE ( addr -- )
      переносит в область памяти addr всю служебную информацию 
      сопроцессора, ВКЛЮЧАЯ регистры. Сопроцессор инициализируется.
      Область памяти должна быть 108 байт. Не менее.
FRSTOR ( addr -- )
      восстанавливает состояние сопроцессора из области памяти addr.
      ВКЛЮЧАЯ сохраненные ранее регистры.
FSTATE ( -- )
      печатает состояние каждого регистра.
      
FD< ( F: r1 D: n -- F: r1 D: f )
      f = r1 < n
      Введено для удобства.

Константы сопроцессора.
Кладут на арифметический стек некую константу, `зашитую` в сопроцессоре.
FCONST0 - 0.0 , - оно же `.e` - обе константы
FCONST1 - 1.0   - оно же `1e`
FPI     - число PI
FLG2    - Log{10}2 - логарифм 2 по основанию 10
FLN2    - Ln 2 - логарифм 2 по основанию е
FL2T    - Log{2}10
FL2E    - Log{2}e , где е - всем известная константа
Будет вскоре и раздел `программные константы` - если поможете сформировать :)

Это далеко не все слова, но остальные `для служебного пользования`, и Вам 
вряд ли пригодятся.

Ввод чисел:
Синтаксис числа любой - но в следующих рамках:
1. Система счисления ОБЯЗАТЕЛЬНО должна быть десятичной
2. Вещественное число должно быть не меньше 2-х символов, включая `e`,
   например, `.Е`, или `0Е` - сформирует на арифметическом стеке 0.0
3. Точка не обязательна, `Е` обязательно
4. Если после `Е` будет встречен знак `.`, то начиная с 
   этого символа до конца часть числа не будет восприниматься, без сообщения 
   об ошибке (но это `экзотический` случай).
5. Числа после `e` необязательны.

Такие жесткие рамки введены для уверенного отделения числа в 16 -ичной 
системе счисления от вещественного числа.

FLIT, компилирует столько:

компиляция литералов - 
FSINGLE - 12 байт
FDOUBLE - 16 байт
FLONG   - 18 байт


О арифметическом стеке:
  Для максимальной скорости глубина стека контролируется аппаратно.
  Поэтому если глубина стека больше 8, то чаще всего виснет, в 
  зависимости от настроения сопроцессора, но данные портятся всегда.
  На самом деле FDEPTH показывает числа 0...7 так как это связано с 
  аппаратными особенностями. 
  Например, у меня в проектах глубина арифметического стека очень редко бывает 
  4-5 элементов, чаще 2-3.

Советы по отладке (то есть если не работает)
1. Проверьте визуально, не пишите слов, больших чем несколько строк - 
   сэкономите много Вашего драгоценного времени - на личном примере знаю.
2. Просмотрите на предмет наличия разных неприятностей типа:
        - деление на ноль
        - логарифм 0 или отрицательного числа
          Перед логарифмом можно вставить 
                  FDUP F0< FDUP F0= OR INVERT IF FLOG ...
        - переполнение при копировании данных с арифм. стека на стек данных
        - деление одной бесконечности на другую (случай из практики)
        
   Если программа виснет и если это в вычислениях, то наверняка переполнен 
   арифметический стек или забыли вещественный параметр у какого-нибудь 
   слова. (ТОЛЬКО 2 причины зависания)
3. Если Вы дошли до этого пункта и не нашли ошибку, то
   после арифметических опреаций ставьте проверочное слово FABORT - 
   найдете где программа слетает и просмотрите содержимое стеков и 
   подумаете и сделаете выводы.
4. Если Вы уже в этом пункте, то, если Вы считаете себя не новичком на 
   ФОРТе, то побыстрее связывайтесь со мной - возможно, что ошибка не в Вашей 
   программе.
   
Но, эта библиотека участвует в достаточно серьезном математическом 
проекте FORTHSIM - система моделирования стационарных как 
непрерывных так и дискретных систем, 
и глюков все меньше и меньше...


Свяжитесь, пожалуйста, со мной в следующих случаях:
- Если Вы заметите расхождение со стандартом, неизвестное мне.
- Если возникла проблема в работе с данной библиотекой или Вы нашли 
  неточности в работе или даже ошибки.
- Если у Вас есть пожелания или предложения
- Если Вы хотите, чтобы какая-нибудь математическая функция была введена в 
  состав библиотеки.


Успехов Вам.           Дмитрий Якимов.     28.09.99
