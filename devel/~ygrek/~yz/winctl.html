<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="forth.css" type="text/css">
<title>Оконная библиотека: элементы управления</title>
</head>

<body background="pic/grid.gif">

<h1 class=lib><u>winctl.f</u>
&nbsp;Оконная библиотека: элементы управления
</h1>

<br><a href="winctl.html#common">1. Общие свойства элементов управления</a>
<br><a href="winctl.html#status">2. Строки статуса</a>
<br><a href="winctl.html#static">3. Статические элементы</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="winctl.html#statprop">Свойства</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="winctl.html#statdecor">Декоративные элементы</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="winctl.html#statpic">Картинки</a>
<br><a href="winctl.html#button">4. Кнопки</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="winctl.html#butt">Обычные кнопки</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="winctl.html#checkbox">Кнопки с отметкой</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="winctl.html#radio">Радиокнопки</a>
<br><a href="winctl.html#edit">5. Строки ввода</a>
<br><a href="winctl.html#list">6. Списки</a>
<br><a href="winctl.html#combo">7. Комбинированные списки</a>
<br><a href="winctl.html#scroll">8. Полосы прокрутки</a>
<br><a href="winctl.html#ctl">9. Управление элементами</a>
<br><a href="winctl.html#grid">10. Сетки</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="winctl.html#griddef">Описание размещения объектов</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="winctl.html#gridalg">Алгоритм размещения</a>
<br><a href="winctl.html#modal">11. Модальные диалоговые окна</a>

<br>
<a name="common"></a><h1>1. Общие свойства элементов управления</h1>

<p>Все элементы управления разделяют приведенные ниже свойства. Впрочем,
для конкретного элемента не каждое свойство имеет смысл. Например, строки
статуса не могут быть выравнены, поэтому <i>-align</i> к ним неприменимо.
</p>

<i>-font</i>
<p>Шрифт надписей элемента. Шрифты создаются с помощью слова <a
href="winlib.html#font"><u>create-font</u></a>.
</p>

<i>-align</i>
<p>Выравнивание надписи в пределах элементах. Могут устанавливаться
следующие константы: <i>left</i> - влево, <i>center</i> - по центру,
<i>right</i> - вправо.
</p>

<i>-command</i>
<p>Слово, которое будет выполнено при поступлении "главной" команды. Главная
команда различается для каждого элемента. Для кнопок - это нажатие на
кнопку, для строки статуса - щелчок по ней и т.д. По умолчанию <u>NOOP</u>.
<table class=win><tr><td width=5%><img src="pic/win.gif"><td>
Кстати будет заметить, что Windows очень болезненно относится к своему
стеку. Поэтому во всех обработчиках типа <i>-command</i>, <i>-painter</i>
и иже с ними, вызываемых из оконной процедуры, стек нужно обязательно
оставлять в том же состоянии, в каком он был при вызове. Иначе ждите GPF,
а то и полного зависания машины.
</table>
</p>

<i>-notify</i>
<p>Список (<u>MESSAGES:</u>...<u>MESSAGES;</u>) обработчиков уведомлений.
Уведомления зависят от конкретного элемента. При запуске обработчика <i>lparam</i> указывает на
первое слово после стандартного NMHDR, поскольку там находится обычно
самое интересное. Обратите внимание: в этих обработчиках НЕ нужно ставить
флажок, обработан элемент или нет, в отличие от обработчиков <i>-pre</i> и
<i>-wndproc</i>.
</p>

<i>-updown</i>
<p>Некоторые элементы могут быть дополнены двумя стрелочками, так
называемым спином. В этом свойстве хранится спин, если таковой имеется.
Подробнее о спинах смотрите <a href="wincc.html#updown">здесь</a>.
</p>

<i>-tooltip</i>
<p>Всплывающая подсказка для элемента. Устанавливается и читается точно так же,
как и свойство <i>-text</i>. Подробнее о подсказках смотрите <a href="wincc.html#tooltip">здесь</a>.
</p>

<i>-painter</i>
<p>Процедура нестандартной отрисовки элементов (для элементов с флагом
customdraw). При вызове переменная <i>windc</i> указывает контекст
рисования, <i>paint-rect</i> на границы рисования. Остальные параметры
доступны через <i>lparam</i>.
</p>

<br>
<a name="status"></a><h1>2. Строки статуса</h1>

<u>create-status</u> <i>( win -- )</i>
<p>Добавить к окну строку статуса. Строка статуса при необходимости доступна через
свойство <i>-status</i> окна.
</p>

<u>split-status</u> <i>( array no win -- )</i>
<p>Разделить строку статуса на <i>no</i> частей. В массиве <i>array</i>
содержатся <i>no</i> ячеек - правые границы каждой части (в пикселях) или
-1, показывающая, что ячейка продолжается до конца строки статуса.
</p>

<u>set-status</u> <i>( z no win -- )</i>
<p>Установить указанный текст в нужную часть статусной строки. Части
нумеруются с нуля.
</p>

<br>
<a name="static"></a><h1>3. Статические элементы</h1>

<a name="statprop"></a><h2>Свойства</h2>

Помимо свойств, общих для всех элементов, у статических элементов
добавляются следующие свойства:
</p>

<i>-xpad, -ypad</i>
<p>Горизонтальное и вертикальное расстояние от границы кнопки до надписи.
</p>

<i>-image</i>
<p>Картинка (для соответствующих элементов - <u>bitmap</u>, <u>bitmap-button</u>).
</p>

<i>-state</i>
<p>Состояние элемента управления.
</p>

<a name="statdecor"></a><h2>Декоративные элементы</h2>

<u>rectangle</u> <i>( -- ctl )</i>
<p>Создать прямоугольник.
</p>

<u>hline</u> <i>( -- ctl )</i>
<p>Создать горизонтальную линию.
</p>

<u>filler</u> <i>( -- ctl )</i>
<p>Создать невидимый элемент - заполнитель места.
</p>

<u>label</u> <i>( z -- ctl )</i>
<p>Создать надпись.
</p>

<u>groupbox</u> <i>( z -- ctl )</i>
<p>Создать рамку с надписью. См. также <a href="winctl.html#grid"><u>-boxed</u></a>.
</p>

<a name="statpic"></a><h2>Картинки</h2>

<u>icon</u> <i>( hicon -- ctl )</i>
<p>Создать статическую иконку. Передается дескриптор иконки.
</p>

<u>bitmap</u> <i>( hbitmap -- ctl )</i>
<p>Создать статическую картинку.
</p>

<br>
<a name="button"></a><h1>4. Кнопки</h1>
Свойства кнопок такие же, как и свойства статических объектов.

<a name="butt"></a><h2>Обычные кнопки</h2>

<u>button</u> <i>( z -- ctl )</i>
<p>Создает обычную нажимающуюся кнопку. При нажатии кнопки вызывается
слово, хранящееся в <i>-command</i>. Остальные уведомления о состоянии
кнопки приходят через <i>-notify</i>.
<table class=win><tr><td width=5%><img src="pic/win.gif"><td>
Фон и надписи обычных кнопок программно окрасить нельзя. Они могут быть только
стандартного системного цвета.
</table>
</p>

<u>icon-button</u> <i>( hicon -- ctl )</i>
<p>Создает кнопку-иконку.
</p>

<u>bitmap-button</u> <i>( hbitmap -- ctl)</i>
<p>Создает кнопку-картинку.
</p>

<u>-defbutton</u> <i>( -- )</i>
<p>Объявляет последнюю созданную кнопку кнопкой по умолчанию. Такая кнопка
выделяется визуально более толстой рамкой. Если нажать Enter,
находясь в диалоговом окне, будет выполнена <i>-command</i> кнопки по
умолчанию.
</p>

<u>ok-button</u> <i>( z xt -- ctl)</i>
<p>Вспомогательное слово: объявляет кнопку по умолчанию с надписью
<i>z</i> и командой <i>xt</i>.
</p>

<u>cancel-button</u> <i>( z -- ctl)</i>
<p>Вспомогательное слово: объявляет кнопку "Отмена". При нажатии на нее
модальный диалог будет снят с кодом <i>IDCANCEL</i>.
</p>

<a name="checkbox"></a><h2>Кнопки с отметкой</h2>

<u>checkbox</u> <i>( z -- ctl )</i>
<p>Создает кнопку с отметкой. Состояние кнопки можно узнать
(<u>ctl -state@</u>), установить (<u>TRUE ctl -state!</u>) или сбросить (<u>FALSE ctl -state!</u>).
</p>

<a name="radio"></a><h2>Радиокнопки</h2>

<u>radio</u> <i>( value z -- )</i>
<p>Создать радиокнопку, входящую в последнюю объявленную группу. При
выборе кнопки в эту группу будет записано значение <i>value</i>. Можно узнать
текущее состояние кнопки (<u>ctl -state@</u>) или установить конкретную кнопку
(<u>TRUE ctl -state!</u>).
</p>

<u>GROUP</u> <i>( ->bl; -- )</i>
<p>Объявить переменную, в которой будет храниться состояние группы. Узнать, какая из кнопок в группе установлена,
можно, прочитав значение группы как обычную переменную. Если ни одна из кнопок не установлена,
возвращается -1.
</p>

<u>start-group</u> <i>( group -- )</i>
<p>Все последующие радиокнопки будут относиться к указанной группе.
</p>

<u>clear-group</u> <i>( group -- )</i>
<p>Сбросить все кнопки в группе.
</p>

<code>
GROUP gg
<br>gg start-group
<br>&nbsp;&nbsp;0 " Veni" radio&nbsp;&nbsp;1 " Vidi" radio&nbsp;&nbsp;2 " Vici" radio
<br><br>gg @ <kbd>\ установленная кнопка или -1</kbd>
</code>

<br>
<a name="edit"></a><h1>5. Строки ввода</h1>

<u>edit</u> <i>( -- ctl )</i>
<p>Создать однострочный элемент ввода. Высота элемента устанавливается по
текущему шрифту.
</p>

<u>limit-edit</u> <i>( n ctl -- )</i>
<p>Ограничить поле ввода <i>n</i> символами.
</p>

<u>multiedit</u> <i>( -- ctl )</i>
<p>Создать многострочный элемент ввода.
</p>

<u>password-edit</u> <i>( -- ctl )</i>
<p>Создать поле ввода пароля (введённые символы маскируются).
</p>

<br>
<a name="list"></a><h1>6. Списки</h1>

Кроме общих для всех элементов свойств простые и комбинированные списки
расширены следующим свойством:
</p>

<i>-selected</i>
<p>Номер текущей выбранной строки. Строки нумеруются от нуля. Свойство можно читать и записывать.
</p>

<u>listbox</u> <i>( -- ctl)</i>
<p>Создает новый пустой список.
</p>

<u>lb-addstring</u> <i>( z ctl -- )</i>
<p>Добавляет в конец списка новую строку.
</p>

<u>lb-insertstring</u> <i>( z pos ctl -- )</i>
<p>Вставляет новую строку в указанную позицию списка.
</p>

<u>lb-clear</u> <i>( ctl -- )</i>
<p>Очищает список.
</p>

<u>lb-count</u> <i>( ctl -- n)</i>
<p>Возвращает количество элементов в списке.
</p>

<u>lb-deletestring</u> <i>( pos ctl -- )</i>
<p>Удаляет строку в указанной позиции.
</p>

<u>fromlist</u> <i>( adr pos ctl -- )</i>
<p>Заносит по адресу <i>adr</i> строку, хранящуюся в списке в указанной
позиции.
</p>

<u>lb-dir</u> <i>( mask attr ctl -- )</i>
<p>Заполняет список именами файлов. <i>Mask</i> - маска файлов,
<i>attr</i> - аттрибуты файлов.
</p>

<br>
<a name="combo"></a><h1>7. Комбинированные списки</h1>

<u>combo</u> <i>( -- ctl)</i>
<p>Создает новый пустой комбинированный список.
</p>

<u>addstring</u> <i>( z ctl -- )</i>
<p>Добавляет в конец списка новую строку.
</p>

<u>insertstring</u> <i>( z pos ctl -- )</i>
<p>Вставляет новую строку в указанную позицию списка.
</p>

<u>clear-combo</u> <i>( -- )</i>
<p>Очищает список.
</p>

<u>combo-count</u> <i>( ctl -- n)</i>
<p>Возвращает количество элементов в списке.
</p>

<u>deletestring</u> <i>( pos ctl -- )</i>
<p>Удаляет строку в указанной позиции.
</p>

<u>fromcombo</u> <i>( adr pos ctl -- )</i>
<p>Заносит по адресу <i>adr</i> строку, хранящуюся в списке в указанной
позиции.
</p>

<u>combo-dir</u> <i>( mask attr ctl -- )</i>
<p>Заполняет список именами файлов. <i>Mask</i> - маска файлов,
<i>attr</i> - аттрибуты файлов.
</p>

<br>
<a name="scroll"></a><h1>8. Полосы прокрутки</h1>

<i>-pos</i>
<p>Текущая позиция бегунка. Свойство можно читать и записывать.
</p>

<i>-min</i>
<p>Минимальная позиция бегунка.
</p>

<i>-max</i>
<p>Максимальная позиция бегунка.
</p>

<u>hscroll</u> <i>( -- ctl )</i>
<p>Создает горизонтальную полосу прокрутки. Не путайте этот элемент управления с полосой прокрутки окна.
Сообщения от полосы прокрутки приходят на ее список обработчиков <i>-notify</i>.
</p>

<u>vscroll</u> <i>( -- ctl)</i>
<p>Создает вертикальную полосу прокрутки.
</p>

<br>
<a name="ctl"></a><h1>9. Управление элементами</h1>

<u>this</u>
<p>Переменная, в которой хранится последний созданный элемент управления.
</p>

<u>ctlresize</u> <i>( w h ctl -- )</i>
<p>Меняет размер элемента управления.
</p>

<u>ctlmove</u> <i>( x y ctl -- )</i>
<p>Перемещает элемент управления в указанное место. Координаты отмеряются
в пикселях от левого верхнего угла клиентской области родительского окна.
</p>

<u>ctlshow</u> <i>( ctl -- )</i>
<p>Показать элемент управления
</p>

<u>ctlhide</u> <i>( ctl -- )</i>
<p>Спрятать элемент управления.
</p>

<u>place</u> <i>( x y ctl -- )</i>
<p>Разместить элемент управления в указанном месте окна
<u>current-window</u>. Это слово необходимо лишь в особых случаях - когда
стандартное размещение с помощью <a href="winctl.html#grid">сеток</a> почему-либо не устраивает
программиста.
</p>

<u>remove</u> <i>( ctl -- )</i>
<p>Удаляет элемент с родительского окна, но оставляет его в памяти. Слово,
противоположное <u>place</u>.
</p>

<p>Если нужно одновременно установить сразу несколько свойств, можно
использовать операцию групповой установки. Понять ее работу проще всего на
следующем примере:
</p>

<code><pre>
" Пример" label  blue this -color!  white this -bgcolor!
<kbd>эквивалентно</kbd>
" Пример" label  (/ -color blue  -bgcolor white /)
</pre></code>

<p>Обратите внимание, что после названия свойства ставить восклицательный
знак не нужно. В операции групповой установки можно кроме настоящих
свойств использовать некоторые псевдосвойства. Например, выставить размер
элемента управления можно так:
</p>
<code><pre>
edit (/ -size 120 20 /) |
</pre></code>

<p>А так определить имя элемента:</p>
<code><pre>
0 VALUE ec
<kbd>...</kbd>
edit (/ -name ec /) |
</pre></code>

<br>
<a name="grid"></a><h1>10. Сетки</h1>

Широко популярны два метода расстановки элементов управления по окну.
Первый из них, предлагаемый компилятором ресурсов, заключается в том, что
программист, расчертив предварительно на миллиметровке диалоговую панель,
сам назначает каждому элементу координаты. Метод довольно скучный и
неудобный. Второй метод - в духе графических сред - сводится к расстановке
тех же панелей, но уже на экране, а координаты в файл ресурсов записывает
сама машина. Этот метод удобней первого, но все-таки достаточно
утомительный и, не побоюсь, этого слова, примитивный и отдающий глубоким
бессловесным детством. В идеальном методе
надо только сказать, что должно быть на экране, и сказать примерно, не
вдаваясь в точные вычисления. Сетки есть попытка изобразить нечто в духе
идеального метода. Собственно, это второе издание воображаемых таблиц из
программы <a href="blank.html#23">Blank</a>, издание расширенное и
дополненное согласно опыту эксплуатации и пожеланиям пользователей.
<br><br>
Представьте, что по всей поверхности окна раскинута невидимая сетка из
горизонтальных рядов. Каждый ряд делится на произвольное число колонок. В
каждой ячейке этой сетки живет один из элементов управления или другая,
вложенная, сетка. Есть слова, которые задают различные параметры клетки
сетки - поля, выравнивание элемента, ее ширину и т.д. При изменении
размеров окна сетка соответствующим образом растягивается или сжимается,
переставляя в нужные места своих обитателей. Существует определенный
предел, дальше которого сетка уже не сжимается - когда все элементы
управления занимают свои места плюс вокруг них стоят необходимые поля. По
такому размеру сетки и выставляется первоначально размер окна. Если окно
увеличивается, в ячейки сетки добавляется дополнительное пространство или
же растягивается сам обитатель - в зависимости от пожеланий программиста.
Некоторые обитатели могут занимать фиксированный размер, а их ячейки не
будут растягиваться - это нужно при точном совмещении, например,
заголовков или вкладок.
<br><br>
Сетки могут вкладываться друг в друга. Не забывайте вставлять вложенную
сетку в объемлющую словом <u>|</u>.
<br><br>
Пока что сетки являются статическими объектами. Они подключаются один раз
и более не меняются. Вполне возможно было бы запрограммировать добавление
и удаление новых ячеек сетки, но пока непонятно, сильно ли это необходимо
в практических задачах. Возможно также сделать перерасчет сетки при
изменении размеров ее обитателя, но опять-таки необходимость таких вещей
пока не ясна.
<br><br>
Сетка окна хранится в его свойстве <i>-grid</i>. Подключение сетки к окну
словом <u>-grid!</u> вызывает изменение размеров окна по размеру сетки.

<a name="griddef"></a><h2>Описание размещения объектов</h2>

<u>GRID</u> <i>( -- )</i>
<p>Начать новую сетку.
</p>

<u>===</u> <i>( -- )</i>
<p>Разделитель рядов сетки.
</p>

<u>|</u> <i>( ctl/grid -- )</i>
<p>Добавить новую ячейку в текущий ряд и занести в нее элемент управления
или вложенную сетку.
</p>

<u>GRID;</u> <i>( -- grid )</i>
<p>Закончить описание сетки.
</p>

Расположение и размеры обитателя ячейки описывается следующим образом:
</p>

<u>-left</u>, <u>-center</u>, <u>-right</u> <i>( -- )</i>
<p>Выравнивать обитателя в пределах ячейки: влево, по центру, вправо.
</p>

<u>-top</u>, <u>-middle</u>, <u>-bottom</u> <i>( -- )</i>
<p>Выравнивать обитателя в пределах ячейки: по верху, по середине, по низу.
</p>

<u>-xmargin</u>, <u>-ymargin</u> <i>( n -- )</i>
<p>Установить горизонтальные или вертикальные поля в <i>n</i> пикселей
каждое.
</p>

<u>-xspan</u>, <u>-yspan</u> <i>( -- )</i>
<p>При масштабировании сетки обитатель ячейки будет растянут в
горизонтальном или вертикальном направлении так, чтобы занять всю ячейку
за исключением полей.
</p>

<u>-width</u>, <u>-height</u> <i>( n -- )</i>
<p>Клетка будет занимать ровно <i>n</i> процентов от ширины или высоты
всей сетки.
</p>

<u>-xfixed</u> <i>( -- )</i>
<p>Клетка фиксирована в горизонтальном направлении, и
ее ширина не будет меняться при масштабировании.
</p>

<u>-yfixed</u> <i>( -- )</i>
<p>Текущий ряд зафиксирован и его высота не будет меняться при
масштабировании.
</p>

<u>-boxed</u> <i>( -- )</i>
<p>Текущая сетка будет окружена обводкой, проходящей по середине полей. Имеет
смысл для вложенных сеток.
</p>

<u>-bevel</u> <i>( -- )</i>
<p>Текущая сетка будет выглядеть вдавленной в родительское окно. Имеет
смысл для вложенных сеток.
</p>

<a name="gridalg"></a><h2>Алгоритм размещения</h2>

<h4>Расчет параметров cетки</h4>

<ol>
<li>Находим ширину и высоту каждого обитателя клетки, прибавляем поля и
получаем ширину и высоту каждой ячейки сетки.
<li>Находим ширину каждого ряда как сумму ширин всех его ячеек и высоту
ряда как высоту самой высокой из ячеек.
<li>Находим ширину всей таблицы как ширину самого широкого ее ряда и
высоту таблицы как сумму высот всех рядов.
<li>Для каждого ряда находим сумму всех фиксированных клеток этого ряда.
<li>Для таблицы находим общую высоту всех фиксированных рядов.
<li>Высчитываем ширину каждой клетки как относительную долю от ширины ряда
минус фиксированные клетки ряда; высчитываем высоту каждого ряда как
относительную долю от высоты таблицы минус сумма фиксированных рядов.
</ol>

<h4>Отображение cетки на окно</h4>
<ol>
<li>Если сумма ширин ячеек какого-либо ряда меньше общей ширины таблицы,
добавляем в каждую ячейку (кроме фиксированных) дополнительное место
пропорционально ширине ячейки.
<li>Пересчитываем относительные доли в точки по текущим размерам окна.
<li>Устанавливаем положение и размеры каждой ячейки и размещаем в ней ее
обитателя.
</ol>

<br>
<a name="modal"></a><h1>11. Модальные диалоговые окна.</h1>

Создать немодальное диалоговое окно несложно. Собственно, для этого
достаточно только применить уже описанные выше слова: создать окно
(необязательно через <u>dialog-window</u>), присвоить ему сетку и, если
нужно, чтобы работали диалоговые клавиши, занести <u>TRUE</u> в свойство
<i>-dialog</i>. Для окон <u>dialog-window</u> последнее не требуется.
<br><br>
Сложнее с модальным окном, то есть окном, которое не дает переключиться на
другие окна до своего завершения. Здесь уже требуется кое-какая
дополнительная инфраструктура, заодно облегчающая пользование самим окном.
</p>

<br><br>
<u>MODAL...</u> <i>( ztitle -- )</i>
<p>Создает безымянное диалоговое окно с заголовком <i>ztitle</i>.
Обращаться к такому окну можно через переменную <u>dialog</u>.
</p>

<u>SHOW</u> <i>( grid -- )</i>
<p>Присваивает сетку диалоговому окну и показывает его в центре
главного окна программы. Ожидает, пока пользователь завершит работу
диалога и скрывает диалоговое окно. Если требуется провести какие-либо
дополнительные действия после обработки пользовательскогло ввода
не закрывая окно (например сообщить что данные не корректны и попросить
исправить введённое), то надо использовать следующие 4 слова.
</p>

<u>INITMODAL</u> <i>( grid -- )</i>
<p>Присваивает сетку диалоговому окну.
</p>

<u>SHOWMODAL</u> <i>( -- )</i>
<p>Показывает модальное окно.
</p>

<u>LOOPMODAL</u> <i>( -- )</i>
<p>Цикл сообщений модального окна. После выхода устанавлено
значение dialog-termination - например IDOK или IDCANCEL
</p>

<u>HIDEMODAL</u> <i>( -- )</i>
<p>Cкрывает модальное окно.
</p>

<u>...MODAL</u> <i>( -- )</i>
<p>Уничтожает безымянное диалоговое окно.
</p>

<u>end-dialog</u> <i>( code -- )</i>
<p>Устанавливает указанный код возврата и завершает диалог.
</p>

<u>dialog-ok</u> <i>( -- )</i>
<p>Завершает диалог с кодом <i>IDOK</i> (успешное завершение)
</p>

<u>dialog-cancel</u> <i>( -- )</i>
<p>Завершает диалог с кодом <i>IDCANCEL</i> (диалог отменен)
</p>

<u>dialog-termination</u> <i>( -- )</i>
<p>После выполнения команды <u>SHOW</u> из этой переменной можно узнать, как закончился диалог.
В ней хранится IDOK, если пользователь нажал кнопку Enter и была
установлена кнопка по умолчанию; IDCANCEL, если пользователь нажал Esc или
закрыл диалог крестиком в углу. Программы могут устанавливать также
собственные коды завершения диалога словом <u>end-dialog</u>.
</p>

<code>
PROC: defbutt
<br>  " Диалог завершился успешно" msg
<br>  dialog-ok
<br>PROC;
<kbd><br>\ ...</kbd>
<br>" Пример диалога" MODAL...
<br>GRID
<br>...
<br>" Ok" defbutt ok-button |
<kbd><br>\ ...</kbd>
<br>GRID; SHOW
<br><kbd>\ Теперь самое время прочитать значения элементов управления диалога</kbd>
<br>...MODAL
</code>

<br>

<code>
PROC: dialog
<br>
<br>    " Example"  MODAL...
<br>
<br>      grid \ какая-то сетка
<br>
<br>      INITMODAL
<br>      SHOWMODAL
<br>
<br>      .name winfocus \ устанавливаем фокус ввода
<br>
<br>      BEGIN
<br>
<br>       LOOPMODAL
<br>
<br>       1 0 DO  \ обрабатываем ввод, диалог ещё на экране со всем своим содержимым, включая юзерский ввод
<br>        dialog-termination W: IDOK <> IF TRUE LEAVE THEN
<br>        .name -text# 0= IF " Name cannot be empty" err!  .name winfocus FALSE LEAVE THEN
<br>        .days -text# 0= IF " Number cannot be empty" err!  .days winfocus FALSE LEAVE THEN
<br>
<br>       ... \ тут всё хорошо, ввод корректен, обрабатываем
<br>
<br>        TRUE
<br>
<br>       LOOP \ ----- 1 0 DO
<br>
<br>      UNTIL \ если здесь FALSE то возвращаемcя в диалог, TRUE - выходим
<br>
<br>      HIDEMODAL \ прячем окно
<br>
<br>    ...MODAL \ убиваем
<br> PROC;
</code>

<code>
<a href="prog/winlib/winctl-example.f"><img src="pic/spf.gif"></a>
Пример работы с элементами управления
</code>

<code>
<a href="prog/winlib/calc.f"><img src="pic/spf.gif"></a>
Пример: преобразование килограммов в фунты (автор: Е. Цымбалов)
</code>

</html>
